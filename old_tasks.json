{
  "tasks": [
    {
      "id": 1,
      "title": "Setup Project Structure and API Configuration",
      "description": "Create the initial project structure in Google Apps Script and implement API configuration functionality for the trading platform.",
      "details": "1. Create a new Google Apps Script project\n2. Set up the basic file structure:\n   - `Config.gs`: Store API configuration and constants\n   - `ApiUtils.gs`: API utility functions\n   - `DataFetcher.gs`: Functions to fetch data from API\n   - `SheetManager.gs`: Functions to manage sheets\n   - `UI.gs`: UI components\n   - `Main.gs`: Main entry point and menu setup\n3. Implement configuration storage using PropertiesService:\n```javascript\nfunction saveApiConfig(apiKey, environment) {\n  const scriptProperties = PropertiesService.getScriptProperties();\n  scriptProperties.setProperty('API_KEY', apiKey);\n  scriptProperties.setProperty('ENVIRONMENT', environment);\n  return true;\n}\n\nfunction getApiConfig() {\n  const scriptProperties = PropertiesService.getScriptProperties();\n  return {\n    apiKey: scriptProperties.getProperty('API_KEY'),\n    environment: scriptProperties.getProperty('ENVIRONMENT')\n  };\n}\n```\n4. Create constants for API endpoints based on environment\n5. Set up onOpen trigger to create custom menu",
      "testStrategy": "1. Verify project structure is correctly set up with all necessary files\n2. Test saving and retrieving API configuration\n3. Confirm custom menu appears when spreadsheet is opened\n4. Manually verify that configuration is persisted between sessions",
      "priority": "high",
      "dependencies": [],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 2,
      "title": "Implement API Utility Functions",
      "description": "Create utility functions for making API requests to the trading platform with proper error handling and rate limiting.",
      "details": "1. Implement a base API request function with error handling:\n```javascript\nfunction makeApiRequest(endpoint, method = 'GET', payload = null) {\n  const config = getApiConfig();\n  if (!config.apiKey) {\n    throw new Error('API key not configured');\n  }\n  \n  const baseUrl = config.environment === 'prod' \n    ? 'https://api.trading212.com/v1' \n    : 'https://demo.trading212.com/v1';\n    \n  const options = {\n    method: method,\n    headers: {\n      'Authorization': `Bearer ${config.apiKey}`,\n      'Content-Type': 'application/json'\n    },\n    muteHttpExceptions: true\n  };\n  \n  if (payload && (method === 'POST' || method === 'PUT')) {\n    options.payload = JSON.stringify(payload);\n  }\n  \n  // Implement caching for GET requests\n  const cacheKey = `${endpoint}_${method}`;\n  const cache = CacheService.getScriptCache();\n  const cachedResponse = method === 'GET' ? cache.get(cacheKey) : null;\n  \n  if (cachedResponse) {\n    return JSON.parse(cachedResponse);\n  }\n  \n  // Implement rate limiting\n  Utilities.sleep(200); // Simple rate limiting\n  \n  try {\n    const response = UrlFetchApp.fetch(`${baseUrl}${endpoint}`, options);\n    const responseCode = response.getResponseCode();\n    const responseText = response.getContentText();\n    \n    if (responseCode >= 200 && responseCode < 300) {\n      const responseData = JSON.parse(responseText);\n      \n      // Cache successful GET responses for 5 minutes\n      if (method === 'GET') {\n        cache.put(cacheKey, responseText, 300);\n      }\n      \n      return responseData;\n    } else {\n      throw new Error(`API Error (${responseCode}): ${responseText}`);\n    }\n  } catch (error) {\n    Logger.log(`API Request Failed: ${error.toString()}`);\n    throw error;\n  }\n}\n```\n2. Create specialized functions for different API endpoints\n3. Implement retry logic for failed requests\n4. Add proper logging for debugging purposes",
      "testStrategy": "1. Test API connection with valid and invalid API keys\n2. Verify error handling works correctly for various error scenarios\n3. Test rate limiting by making multiple consecutive requests\n4. Verify caching works by checking response times for repeated requests\n5. Test with mock responses to simulate different API scenarios",
      "priority": "high",
      "dependencies": [
        1
      ],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 3,
      "title": "Implement Account Information Fetching",
      "description": "Create functions to fetch account information and cash balance from the trading platform API.",
      "details": "1. Implement function to fetch account information:\n```javascript\nfunction fetchAccountInfo() {\n  try {\n    return makeApiRequest('/accounts');\n  } catch (error) {\n    Logger.log(`Failed to fetch account info: ${error}`);\n    throw error;\n  }\n}\n```\n\n2. Implement function to fetch cash balance:\n```javascript\nfunction fetchCashBalance() {\n  try {\n    const accounts = fetchAccountInfo();\n    const balances = [];\n    \n    for (const account of accounts) {\n      const balance = makeApiRequest(`/accounts/${account.id}/cash`);\n      balances.push({\n        accountId: account.id,\n        accountName: account.name,\n        ...balance\n      });\n    }\n    \n    return balances;\n  } catch (error) {\n    Logger.log(`Failed to fetch cash balance: ${error}`);\n    throw error;\n  }\n}\n```\n\n3. Process and flatten the account data structure for easier handling in sheets",
      "testStrategy": "1. Test fetching account information with valid API credentials\n2. Verify cash balance retrieval works for different account types\n3. Test error scenarios (e.g., API unavailable, rate limited)\n4. Verify data structure matches expected format for sheet writing",
      "priority": "high",
      "dependencies": [
        2
      ],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 4,
      "title": "Implement Transaction History Fetching",
      "description": "Create functions to fetch transaction history from the trading platform API.",
      "details": "1. Implement function to fetch transaction history:\n```javascript\nfunction fetchTransactions(dateFrom = null, dateTo = null) {\n  try {\n    let endpoint = '/transactions';\n    const queryParams = [];\n    \n    if (dateFrom) {\n      queryParams.push(`dateFrom=${dateFrom}`);\n    }\n    \n    if (dateTo) {\n      queryParams.push(`dateTo=${dateTo}`);\n    }\n    \n    if (queryParams.length > 0) {\n      endpoint += '?' + queryParams.join('&');\n    }\n    \n    return makeApiRequest(endpoint);\n  } catch (error) {\n    Logger.log(`Failed to fetch transactions: ${error}`);\n    throw error;\n  }\n}\n```\n\n2. Process transaction data to flatten nested structures\n3. Add date formatting and categorization of transaction types\n4. Implement pagination if the API supports it for handling large transaction sets",
      "testStrategy": "1. Test fetching transactions with different date ranges\n2. Verify handling of empty transaction sets\n3. Test with mock data to ensure proper processing of different transaction types\n4. Verify pagination works correctly for large transaction sets\n5. Test error handling for API failures",
      "priority": "high",
      "dependencies": [
        2
      ],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 5,
      "title": "Implement Order History Fetching",
      "description": "Create functions to fetch order history from the trading platform API.",
      "details": "1. Implement function to fetch order history:\n```javascript\nfunction fetchOrders(status = 'all') {\n  try {\n    let endpoint = '/orders';\n    \n    if (status !== 'all') {\n      endpoint += `?status=${status}`;\n    }\n    \n    return makeApiRequest(endpoint);\n  } catch (error) {\n    Logger.log(`Failed to fetch orders: ${error}`);\n    throw error;\n  }\n}\n```\n\n2. Process order data to flatten nested structures\n3. Add functions to filter orders by status (open, closed, canceled)\n4. Implement date and time formatting for order timestamps",
      "testStrategy": "1. Test fetching orders with different status filters\n2. Verify handling of empty order sets\n3. Test with mock data to ensure proper processing of different order types\n4. Verify date formatting works correctly\n5. Test error handling for API failures",
      "priority": "medium",
      "dependencies": [
        2
      ],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 6,
      "title": "Implement Dividend Fetching",
      "description": "Create functions to fetch dividend information from the trading platform API.",
      "details": "1. Implement function to fetch dividends:\n```javascript\nfunction fetchDividends(dateFrom = null, dateTo = null) {\n  try {\n    let endpoint = '/dividends';\n    const queryParams = [];\n    \n    if (dateFrom) {\n      queryParams.push(`dateFrom=${dateFrom}`);\n    }\n    \n    if (dateTo) {\n      queryParams.push(`dateTo=${dateTo}`);\n    }\n    \n    if (queryParams.length > 0) {\n      endpoint += '?' + queryParams.join('&');\n    }\n    \n    return makeApiRequest(endpoint);\n  } catch (error) {\n    Logger.log(`Failed to fetch dividends: ${error}`);\n    throw error;\n  }\n}\n```\n\n2. Process dividend data to flatten nested structures\n3. Add date formatting for dividend payment dates\n4. Calculate dividend yield if not provided by the API",
      "testStrategy": "1. Test fetching dividends with different date ranges\n2. Verify handling of empty dividend sets\n3. Test with mock data to ensure proper processing of different dividend types\n4. Verify date formatting works correctly\n5. Test error handling for API failures",
      "priority": "medium",
      "dependencies": [
        2
      ],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 7,
      "title": "Implement Instrument and Pie Fetching",
      "description": "Create functions to fetch instrument lists and pie configurations from the trading platform API.",
      "details": "1. Implement function to fetch instruments:\n```javascript\nfunction fetchInstruments() {\n  try {\n    return makeApiRequest('/instruments');\n  } catch (error) {\n    Logger.log(`Failed to fetch instruments: ${error}`);\n    throw error;\n  }\n}\n```\n\n2. Implement function to fetch pie configurations:\n```javascript\nfunction fetchPies() {\n  try {\n    return makeApiRequest('/pies');\n  } catch (error) {\n    Logger.log(`Failed to fetch pies: ${error}`);\n    throw error;\n  }\n}\n```\n\n3. Process instrument data to extract relevant fields\n4. Process pie data to flatten nested structures and calculate allocations",
      "testStrategy": "1. Test fetching instruments and verifying data structure\n2. Test fetching pies and verifying data structure\n3. Verify handling of empty instrument and pie sets\n4. Test with mock data to ensure proper processing\n5. Test error handling for API failures",
      "priority": "medium",
      "dependencies": [
        2
      ],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 8,
      "title": "Implement Sheet Management Functions",
      "description": "Create functions to manage sheets within the Google Spreadsheet, including creation, clearing, and formatting.",
      "details": "1. Implement function to get or create a sheet:\n```javascript\nfunction getOrCreateSheet(sheetName) {\n  const ss = SpreadsheetApp.getActiveSpreadsheet();\n  let sheet = ss.getSheetByName(sheetName);\n  \n  if (!sheet) {\n    sheet = ss.insertSheet(sheetName);\n  }\n  \n  return sheet;\n}\n```\n\n2. Implement function to clear sheet data:\n```javascript\nfunction clearSheetData(sheetName, preserveHeaders = true) {\n  const sheet = getOrCreateSheet(sheetName);\n  const startRow = preserveHeaders ? 2 : 1;\n  \n  if (sheet.getLastRow() >= startRow) {\n    sheet.getRange(startRow, 1, sheet.getLastRow() - startRow + 1, sheet.getLastColumn()).clear();\n  }\n  \n  return sheet;\n}\n```\n\n3. Implement function to set headers:\n```javascript\nfunction setSheetHeaders(sheetName, headers) {\n  const sheet = getOrCreateSheet(sheetName);\n  sheet.getRange(1, 1, 1, headers.length).setValues([headers]).setFontWeight('bold');\n  return sheet;\n}\n```\n\n4. Implement function to apply formatting to specific columns:\n```javascript\nfunction formatSheetColumns(sheet, formatConfigs) {\n  for (const config of formatConfigs) {\n    const range = sheet.getRange(config.startRow, config.column, \n                                sheet.getLastRow() - config.startRow + 1, 1);\n    \n    if (config.format === 'currency') {\n      range.setNumberFormat('$#,##0.00');\n    } else if (config.format === 'date') {\n      range.setNumberFormat('yyyy-mm-dd');\n    } else if (config.format === 'datetime') {\n      range.setNumberFormat('yyyy-mm-dd hh:mm:ss');\n    } else if (config.format === 'percent') {\n      range.setNumberFormat('0.00%');\n    }\n  }\n}\n```",
      "testStrategy": "1. Test creating new sheets and accessing existing ones\n2. Verify clearing sheet data with and without preserving headers\n3. Test setting headers and verifying formatting\n4. Test applying different formatting types to columns\n5. Verify behavior with empty sheets and edge cases",
      "priority": "high",
      "dependencies": [
        1
      ],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 9,
      "title": "Implement Data Writing Functions",
      "description": "Create functions to write fetched data to the appropriate sheets with proper formatting.",
      "details": "1. Implement generic function to write data to a sheet:\n```javascript\nfunction writeDataToSheet(sheetName, data, headers, formatConfigs = []) {\n  if (!data || data.length === 0) {\n    Logger.log(`No data to write to ${sheetName}`);\n    return;\n  }\n  \n  const sheet = clearSheetData(sheetName);\n  setSheetHeaders(sheetName, headers);\n  \n  // Prepare rows for writing\n  const rows = data.map(item => {\n    return headers.map(header => {\n      const value = item[header] || '';\n      return value;\n    });\n  });\n  \n  // Write data\n  sheet.getRange(2, 1, rows.length, headers.length).setValues(rows);\n  \n  // Apply formatting\n  formatSheetColumns(sheet, formatConfigs);\n  \n  // Auto-resize columns for better readability\n  sheet.autoResizeColumns(1, headers.length);\n}\n```\n\n2. Implement specific functions for each data type:\n```javascript\nfunction writeAccountInfoToSheet(data) {\n  const headers = ['accountId', 'accountName', 'currency', 'type', 'status'];\n  const formatConfigs = [];\n  writeDataToSheet('Account Info', data, headers, formatConfigs);\n}\n\nfunction writeCashBalanceToSheet(data) {\n  const headers = ['accountId', 'accountName', 'currency', 'amount', 'updatedAt'];\n  const formatConfigs = [\n    { column: 4, startRow: 2, format: 'currency' },\n    { column: 5, startRow: 2, format: 'datetime' }\n  ];\n  writeDataToSheet('Cash Balance', data, headers, formatConfigs);\n}\n\nfunction writeTransactionsToSheet(data) {\n  const headers = ['id', 'accountId', 'instrumentId', 'type', 'direction', 'quantity', 'price', 'amount', 'fee', 'date', 'status'];\n  const formatConfigs = [\n    { column: 6, startRow: 2, format: 'number' },\n    { column: 7, startRow: 2, format: 'currency' },\n    { column: 8, startRow: 2, format: 'currency' },\n    { column: 9, startRow: 2, format: 'currency' },\n    { column: 10, startRow: 2, format: 'datetime' }\n  ];\n  writeDataToSheet('Transactions', data, headers, formatConfigs);\n}\n```\n\n3. Implement similar functions for orders, dividends, instruments, and pies",
      "testStrategy": "1. Test writing different data types to sheets\n2. Verify formatting is correctly applied\n3. Test handling of empty data sets\n4. Test with mock data to ensure proper data transformation\n5. Verify auto-resizing of columns works correctly",
      "priority": "high",
      "dependencies": [
        3,
        4,
        5,
        6,
        7,
        8
      ],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 10,
      "title": "Implement UI for API Configuration",
      "description": "Create a user interface for configuring the API key and environment.",
      "details": "1. Implement function to show API configuration modal:\n```javascript\nfunction showApiConfigModal() {\n  const config = getApiConfig();\n  \n  const ui = HtmlService.createHtmlOutput(`\n    <style>\n      body {\n        font-family: Arial, sans-serif;\n        padding: 10px;\n      }\n      .form-group {\n        margin-bottom: 15px;\n      }\n      label {\n        display: block;\n        margin-bottom: 5px;\n        font-weight: bold;\n      }\n      input, select {\n        width: 100%;\n        padding: 8px;\n        box-sizing: border-box;\n      }\n      .button-container {\n        text-align: right;\n        margin-top: 20px;\n      }\n      button {\n        padding: 8px 15px;\n        background-color: #4285f4;\n        color: white;\n        border: none;\n        border-radius: 4px;\n        cursor: pointer;\n      }\n    </style>\n    <form id=\"apiConfigForm\">\n      <div class=\"form-group\">\n        <label for=\"apiKey\">API Key:</label>\n        <input type=\"password\" id=\"apiKey\" value=\"${config.apiKey || ''}\" required>\n      </div>\n      <div class=\"form-group\">\n        <label for=\"environment\">Environment:</label>\n        <select id=\"environment\">\n          <option value=\"demo\" ${config.environment === 'demo' ? 'selected' : ''}>Demo</option>\n          <option value=\"prod\" ${config.environment === 'prod' ? 'selected' : ''}>Production</option>\n        </select>\n      </div>\n      <div class=\"button-container\">\n        <button type=\"button\" onclick=\"saveConfig()\">Save Configuration</button>\n      </div>\n    </form>\n    <script>\n      function saveConfig() {\n        const apiKey = document.getElementById('apiKey').value;\n        const environment = document.getElementById('environment').value;\n        \n        google.script.run\n          .withSuccessHandler(function() {\n            google.script.host.close();\n          })\n          .withFailureHandler(function(error) {\n            alert('Error: ' + error);\n          })\n          .saveApiConfig(apiKey, environment);\n      }\n    </script>\n  `)\n  .setWidth(400)\n  .setHeight(250)\n  .setTitle('API Configuration');\n  \n  SpreadsheetApp.getUi().showModalDialog(ui, 'API Configuration');\n}\n```\n\n2. Add function to validate API configuration\n3. Add function to test API connection with provided credentials",
      "testStrategy": "1. Test opening the configuration modal\n2. Verify saving configuration works correctly\n3. Test validation of API key format\n4. Verify API connection test works with valid and invalid credentials\n5. Test UI appearance in different browsers",
      "priority": "high",
      "dependencies": [
        1,
        2
      ],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 11,
      "title": "Implement UI for Data Fetching",
      "description": "Create a user interface for triggering data fetches for different data types.",
      "details": "1. Implement function to show data fetch modal:\n```javascript\nfunction showDataFetchModal() {\n  const ui = HtmlService.createHtmlOutput(`\n    <style>\n      body {\n        font-family: Arial, sans-serif;\n        padding: 10px;\n      }\n      .checkbox-group {\n        margin-bottom: 15px;\n      }\n      .date-group {\n        margin-bottom: 15px;\n        display: none;\n      }\n      label {\n        display: block;\n        margin-bottom: 5px;\n        font-weight: bold;\n      }\n      input[type=\"date\"] {\n        width: 100%;\n        padding: 8px;\n        box-sizing: border-box;\n      }\n      .button-container {\n        text-align: right;\n        margin-top: 20px;\n      }\n      button {\n        padding: 8px 15px;\n        background-color: #4285f4;\n        color: white;\n        border: none;\n        border-radius: 4px;\n        cursor: pointer;\n      }\n    </style>\n    <form id=\"dataFetchForm\">\n      <div class=\"checkbox-group\">\n        <label><input type=\"checkbox\" id=\"fetchAccountInfo\" checked> Account Information</label>\n        <label><input type=\"checkbox\" id=\"fetchCashBalance\" checked> Cash Balance</label>\n        <label><input type=\"checkbox\" id=\"fetchTransactions\" checked> Transactions</label>\n        <label><input type=\"checkbox\" id=\"fetchOrders\"> Orders</label>\n        <label><input type=\"checkbox\" id=\"fetchDividends\"> Dividends</label>\n        <label><input type=\"checkbox\" id=\"fetchInstruments\"> Instruments</label>\n        <label><input type=\"checkbox\" id=\"fetchPies\"> Pies</label>\n      </div>\n      \n      <div class=\"date-group\" id=\"dateRangeGroup\">\n        <label for=\"dateFrom\">Date From:</label>\n        <input type=\"date\" id=\"dateFrom\">\n        <label for=\"dateTo\">Date To:</label>\n        <input type=\"date\" id=\"dateTo\">\n      </div>\n      \n      <div class=\"button-container\">\n        <button type=\"button\" onclick=\"fetchData()\">Fetch Data</button>\n      </div>\n    </form>\n    <script>\n      document.getElementById('fetchTransactions').addEventListener('change', toggleDateRange);\n      document.getElementById('fetchDividends').addEventListener('change', toggleDateRange);\n      \n      function toggleDateRange() {\n        const transactionsChecked = document.getElementById('fetchTransactions').checked;\n        const dividendsChecked = document.getElementById('fetchDividends').checked;\n        document.getElementById('dateRangeGroup').style.display = \n          (transactionsChecked || dividendsChecked) ? 'block' : 'none';\n      }\n      \n      function fetchData() {\n        const options = {\n          fetchAccountInfo: document.getElementById('fetchAccountInfo').checked,\n          fetchCashBalance: document.getElementById('fetchCashBalance').checked,\n          fetchTransactions: document.getElementById('fetchTransactions').checked,\n          fetchOrders: document.getElementById('fetchOrders').checked,\n          fetchDividends: document.getElementById('fetchDividends').checked,\n          fetchInstruments: document.getElementById('fetchInstruments').checked,\n          fetchPies: document.getElementById('fetchPies').checked,\n          dateFrom: document.getElementById('dateFrom').value || null,\n          dateTo: document.getElementById('dateTo').value || null\n        };\n        \n        google.script.run\n          .withSuccessHandler(function() {\n            google.script.host.close();\n          })\n          .withFailureHandler(function(error) {\n            alert('Error: ' + error);\n          })\n          .fetchAndWriteData(options);\n      }\n      \n      // Initialize date range visibility\n      toggleDateRange();\n    </script>\n  `)\n  .setWidth(400)\n  .setHeight(400)\n  .setTitle('Fetch Portfolio Data');\n  \n  SpreadsheetApp.getUi().showModalDialog(ui, 'Fetch Portfolio Data');\n}\n```\n\n2. Implement function to handle data fetching based on user selections:\n```javascript\nfunction fetchAndWriteData(options) {\n  try {\n    // Validate API configuration first\n    const config = getApiConfig();\n    if (!config.apiKey) {\n      throw new Error('API key not configured. Please configure API first.');\n    }\n    \n    // Fetch and write data based on options\n    if (options.fetchAccountInfo) {\n      const accountInfo = fetchAccountInfo();\n      writeAccountInfoToSheet(accountInfo);\n    }\n    \n    if (options.fetchCashBalance) {\n      const cashBalance = fetchCashBalance();\n      writeCashBalanceToSheet(cashBalance);\n    }\n    \n    if (options.fetchTransactions) {\n      const transactions = fetchTransactions(options.dateFrom, options.dateTo);\n      writeTransactionsToSheet(transactions);\n    }\n    \n    // Add similar blocks for other data types\n    \n    return true;\n  } catch (error) {\n    Logger.log(`Error in fetchAndWriteData: ${error}`);\n    throw error;\n  }\n}\n```",
      "testStrategy": "1. Test opening the data fetch modal\n2. Verify date range fields appear/disappear based on selections\n3. Test fetching different combinations of data types\n4. Verify error handling when API is not configured\n5. Test with date ranges to ensure proper filtering",
      "priority": "high",
      "dependencies": [
        3,
        4,
        5,
        6,
        7,
        9
      ],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 12,
      "title": "Implement Main Menu and Entry Points",
      "description": "Create the main menu and entry points for the Google Apps Script.",
      "details": "1. Implement onOpen function to create custom menu:\n```javascript\nfunction onOpen() {\n  const ui = SpreadsheetApp.getUi();\n  ui.createMenu('Portfolio Tracker')\n    .addItem('Configure API', 'showApiConfigModal')\n    .addItem('Fetch Data', 'showDataFetchModal')\n    .addSeparator()\n    .addItem('About', 'showAboutDialog')\n    .addToUi();\n}\n```\n\n2. Implement about dialog:\n```javascript\nfunction showAboutDialog() {\n  const ui = SpreadsheetApp.getUi();\n  ui.alert(\n    'Portfolio Tracker',\n    'This Google Apps Script connects to your trading platform to fetch and display portfolio data.\\n\\n' +\n    'Version: 1.0.0\\n' +\n    'Created by: Your Name\\n\\n' +\n    'To get started, configure your API key using the \"Configure API\" menu item.',\n    ui.ButtonSet.OK\n  );\n}\n```\n\n3. Add function to initialize the spreadsheet with default sheets if needed",
      "testStrategy": "1. Test onOpen trigger to ensure menu is created\n2. Verify all menu items work correctly\n3. Test about dialog appearance\n4. Verify initialization of default sheets",
      "priority": "high",
      "dependencies": [
        10,
        11
      ],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 13,
      "title": "Implement Advanced Error Handling and Logging",
      "description": "Enhance error handling and implement comprehensive logging throughout the application.",
      "details": "1. Implement centralized error handling function:\n```javascript\nfunction handleError(error, context = '') {\n  const errorMessage = error.toString();\n  Logger.log(`Error in ${context}: ${errorMessage}`);\n  \n  // Write to error log sheet\n  const sheet = getOrCreateSheet('Error Log');\n  const headers = ['Timestamp', 'Context', 'Error Message'];\n  \n  // Ensure headers exist\n  if (sheet.getLastRow() === 0) {\n    setSheetHeaders('Error Log', headers);\n  }\n  \n  // Add error to log\n  sheet.appendRow([new Date(), context, errorMessage]);\n  \n  return errorMessage;\n}\n```\n\n2. Update API request function to use centralized error handling\n3. Add user-friendly error messages in UI components\n4. Implement function to clear error log\n5. Add option to export error log",
      "testStrategy": "1. Test error handling with various error scenarios\n2. Verify errors are properly logged to the Error Log sheet\n3. Test user-friendly error messages in UI\n4. Verify error log clearing functionality\n5. Test error log export",
      "priority": "medium",
      "dependencies": [
        2,
        9,
        11
      ],
      "status": "pending",
      "subtasks": [
        {
          "id": 1,
          "title": "Implement Centralized Error Handler",
          "description": "Create a centralized error handling module that captures, processes, and standardizes errors throughout the application",
          "dependencies": [],
          "details": "Develop a centralized error handler class that can: 1) Capture errors from different parts of the application, 2) Standardize error format with severity levels, timestamps, and context information, 3) Provide methods for error classification (user errors vs. system errors), 4) Include stack trace information for debugging, 5) Implement error filtering capabilities",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "Integrate UI Error Message System",
          "description": "Create a user-friendly error notification system in the UI that displays appropriate error messages based on error type",
          "dependencies": [
            1
          ],
          "details": "Build UI components for error display including: 1) Toast notifications for non-critical errors, 2) Modal dialogs for critical errors requiring user action, 3) Inline field validation error messages, 4) Error message customization based on error type and severity, 5) Implement retry mechanisms where appropriate",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "Create Error Log Sheet Management",
          "description": "Implement a spreadsheet-based logging system that records all errors with relevant details for troubleshooting",
          "dependencies": [
            1
          ],
          "details": "Develop a logging system that: 1) Creates or accesses a dedicated error log sheet, 2) Records detailed error information including timestamp, error message, severity, user information, and context, 3) Implements row limiting to prevent sheet overflow, 4) Adds formatting for better readability, 5) Includes filtering capabilities within the sheet",
          "status": "pending"
        },
        {
          "id": 4,
          "title": "Implement Error Log Clearing Functionality",
          "description": "Create functionality to clear error logs with appropriate safeguards and confirmation mechanisms",
          "dependencies": [
            3
          ],
          "details": "Build log clearing features including: 1) UI controls to clear logs (buttons, menu items), 2) Confirmation dialogs before clearing logs, 3) Options for selective clearing (by date range, severity, etc.), 4) Backup mechanism before clearing, 5) Access controls to restrict who can clear logs",
          "status": "pending"
        },
        {
          "id": 5,
          "title": "Develop Error Log Export Capabilities",
          "description": "Create functionality to export error logs in various formats for external analysis and reporting",
          "dependencies": [
            3
          ],
          "details": "Implement export features including: 1) Export to CSV/Excel format, 2) PDF export option with formatting, 3) Email export functionality, 4) Filtering options before export (date range, error types), 5) Scheduled automatic exports for critical errors",
          "status": "pending"
        }
      ]
    },
    {
      "id": 14,
      "title": "Implement Data Refresh Automation",
      "description": "Create time-based triggers to automatically refresh data at scheduled intervals.",
      "details": "1. Implement function to create time-based trigger:\n```javascript\nfunction createDailyTrigger() {\n  // Delete existing triggers first\n  deleteTriggers();\n  \n  // Create new daily trigger\n  ScriptApp.newTrigger('fetchAndWriteAllData')\n    .timeBased()\n    .everyDays(1)\n    .atHour(6) // 6 AM\n    .create();\n    \n  return true;\n}\n\nfunction deleteTriggers() {\n  const triggers = ScriptApp.getProjectTriggers();\n  for (const trigger of triggers) {\n    if (trigger.getHandlerFunction() === 'fetchAndWriteAllData') {\n      ScriptApp.deleteTrigger(trigger);\n    }\n  }\n}\n\nfunction fetchAndWriteAllData() {\n  try {\n    fetchAndWriteData({\n      fetchAccountInfo: true,\n      fetchCashBalance: true,\n      fetchTransactions: true,\n      fetchOrders: true,\n      fetchDividends: true,\n      fetchInstruments: true,\n      fetchPies: true,\n      dateFrom: null,\n      dateTo: null\n    });\n  } catch (error) {\n    handleError(error, 'fetchAndWriteAllData');\n  }\n}\n```\n\n2. Add UI for configuring automatic refresh settings\n3. Implement function to check trigger status\n4. Add notification for successful/failed automatic refreshes",
      "testStrategy": "1. Test creating daily trigger\n2. Verify trigger deletion works correctly\n3. Test automatic data refresh functionality\n4. Verify trigger status checking\n5. Test notification system for automatic refreshes",
      "priority": "low",
      "dependencies": [
        9,
        12
      ],
      "status": "pending",
      "subtasks": [
        {
          "id": 1,
          "title": "Implement Time-Based Trigger System",
          "description": "Create the core functionality for time-based triggers that will initiate data refresh operations",
          "dependencies": [],
          "details": "Develop functions to create time-based triggers using Google Apps Script's ScriptApp service. Implement logic to schedule triggers at specific intervals (hourly, daily, weekly). Create helper functions to handle trigger execution and proper error handling. Ensure triggers are properly scoped to the data refresh operations.",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "Develop Trigger Management Functions",
          "description": "Build functions to create, delete, and modify existing triggers",
          "dependencies": [
            1
          ],
          "details": "Create functions to list all active triggers. Implement methods to delete specific triggers by ID. Develop functionality to modify trigger timing and settings. Add validation to prevent duplicate triggers. Document the trigger management API for future reference.",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "Create UI for Refresh Configuration",
          "description": "Design and implement a user interface for configuring data refresh settings",
          "dependencies": [
            2
          ],
          "details": "Design a sidebar or dialog UI using HTML Service or Card Service. Implement form controls for setting refresh frequency and timing. Create UI elements to display currently active triggers. Add buttons to create, edit, or delete triggers. Ensure the UI is intuitive and provides clear feedback on actions.",
          "status": "pending"
        },
        {
          "id": 4,
          "title": "Implement Notification System",
          "description": "Create a notification system to alert users about refresh status and outcomes",
          "dependencies": [
            1,
            3
          ],
          "details": "Develop email notification functionality for successful/failed refreshes. Implement in-app notifications using toast messages or alerts. Create a log of refresh activities accessible to users. Add configuration options for users to customize notification preferences. Ensure notifications include relevant details about the refresh operation.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 15,
      "title": "Implement Data Analysis and Summary Dashboard",
      "description": "Create a summary dashboard sheet with key portfolio metrics and charts.",
      "details": "1. Implement function to create summary dashboard:\n```javascript\nfunction createSummaryDashboard() {\n  const sheet = getOrCreateSheet('Dashboard');\n  sheet.clear();\n  \n  // Set up dashboard layout\n  sheet.getRange('A1:C1').merge().setValue('PORTFOLIO SUMMARY').setFontWeight('bold').setHorizontalAlignment('center');\n  sheet.getRange('A1:C1').setBackground('#f3f3f3');\n  \n  // Account summary section\n  sheet.getRange('A3').setValue('Account Summary').setFontWeight('bold');\n  sheet.getRange('A4').setValue('Total Cash Balance:');\n  sheet.getRange('A5').setValue('Total Portfolio Value:');\n  sheet.getRange('A6').setValue('Total Profit/Loss:');\n  \n  // Transaction summary section\n  sheet.getRange('A8').setValue('Transaction Summary').setFontWeight('bold');\n  sheet.getRange('A9').setValue('Total Buy Transactions:');\n  sheet.getRange('A10').setValue('Total Sell Transactions:');\n  sheet.getRange('A11').setValue('Total Fees Paid:');\n  \n  // Dividend summary section\n  sheet.getRange('A13').setValue('Dividend Summary').setFontWeight('bold');\n  sheet.getRange('A14').setValue('Total Dividends Received:');\n  sheet.getRange('A15').setValue('Dividend Yield:');\n  \n  // Add formulas to calculate values from other sheets\n  updateDashboardValues();\n  \n  // Add charts\n  addPortfolioCharts(sheet);\n  \n  return sheet;\n}\n\nfunction updateDashboardValues() {\n  const sheet = getOrCreateSheet('Dashboard');\n  const cashBalanceSheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName('Cash Balance');\n  const transactionsSheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName('Transactions');\n  const dividendsSheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName('Dividends');\n  \n  // Update cash balance if available\n  if (cashBalanceSheet && cashBalanceSheet.getLastRow() > 1) {\n    const cashRange = cashBalanceSheet.getRange(2, 4, cashBalanceSheet.getLastRow() - 1, 1);\n    sheet.getRange('B4').setFormula('=SUM(\\'' + cashBalanceSheet.getName() + '\\'!D2:D)');\n    sheet.getRange('B4').setNumberFormat('$#,##0.00');\n  }\n  \n  // Update transaction data if available\n  if (transactionsSheet && transactionsSheet.getLastRow() > 1) {\n    // Count buy transactions\n    sheet.getRange('B9').setFormula('=COUNTIFS(\\'' + transactionsSheet.getName() + '\\'!D:D,\"BUY\")');\n    \n    // Count sell transactions\n    sheet.getRange('B10').setFormula('=COUNTIFS(\\'' + transactionsSheet.getName() + '\\'!D:D,\"SELL\")');\n    \n    // Sum fees\n    sheet.getRange('B11').setFormula('=SUM(\\'' + transactionsSheet.getName() + '\\'!I:I)');\n    sheet.getRange('B11').setNumberFormat('$#,##0.00');\n  }\n  \n  // Update dividend data if available\n  if (dividendsSheet && dividendsSheet.getLastRow() > 1) {\n    // Sum dividends\n    sheet.getRange('B14').setFormula('=SUM(\\'' + dividendsSheet.getName() + '\\'!D:D)');\n    sheet.getRange('B14').setNumberFormat('$#,##0.00');\n  }\n}\n\nfunction addPortfolioCharts(sheet) {\n  // Implementation depends on available data and desired charts\n  // This would create charts based on transaction history, portfolio composition, etc.\n}\n```\n\n2. Implement functions to calculate key portfolio metrics\n3. Create charts for portfolio composition, performance over time, etc.\n4. Add refresh button to update dashboard data\n5. Implement conditional formatting for positive/negative values",
      "testStrategy": "1. Test dashboard creation with various data scenarios\n2. Verify formulas correctly calculate values from other sheets\n3. Test chart creation and appearance\n4. Verify dashboard refresh functionality\n5. Test conditional formatting for different value ranges",
      "priority": "low",
      "dependencies": [
        9
      ],
      "status": "pending",
      "subtasks": [
        {
          "id": 1,
          "title": "Design dashboard layout and structure",
          "description": "Create the overall layout and structure for the data analysis and summary dashboard",
          "dependencies": [],
          "details": "Design a clean, intuitive dashboard layout with designated sections for account summary, transaction details, dividend analysis, and portfolio visualization. Create placeholders for all major components and establish a consistent visual style. Include navigation elements if needed and ensure the layout is scalable for future additions.",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "Implement account summary calculations",
          "description": "Develop formulas and logic to calculate and display key account metrics",
          "dependencies": [
            1
          ],
          "details": "Create formulas to calculate total account value, cash balance, invested amount, unrealized gains/losses, and overall performance metrics. Implement conditional formatting to highlight positive/negative changes. Ensure calculations pull data correctly from relevant sheets and handle edge cases like missing data.",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "Create transaction summary metrics",
          "description": "Build transaction analysis section with key metrics and filtering capabilities",
          "dependencies": [
            1
          ],
          "details": "Develop summary tables showing transaction counts by type, recent transactions, and transaction totals. Implement filtering options by date range, transaction type, and account. Create formulas to calculate transaction trends over time and highlight unusual activity. Ensure proper data connections to transaction source sheets.",
          "status": "pending"
        },
        {
          "id": 4,
          "title": "Develop dividend analysis features",
          "description": "Implement dividend tracking, projection, and analysis components",
          "dependencies": [
            1,
            2
          ],
          "details": "Create dividend calendar showing past and projected payments. Implement formulas to calculate dividend yield, growth rate, and annual income projections. Develop visualizations showing dividend income trends and distribution across holdings. Ensure accurate data pulling from dividend history sheets.",
          "status": "pending"
        },
        {
          "id": 5,
          "title": "Implement portfolio visualization charts",
          "description": "Create interactive charts and graphs to visualize portfolio composition and performance",
          "dependencies": [
            1,
            2
          ],
          "details": "Develop pie/donut charts showing asset allocation by sector, asset type, and geography. Create performance line charts showing portfolio value over time. Implement comparison charts for benchmarking against indices. Add interactive elements like tooltips and filtering options where possible.",
          "status": "pending"
        },
        {
          "id": 6,
          "title": "Create dashboard refresh/update mechanisms",
          "description": "Implement functionality to keep dashboard data current and accurate",
          "dependencies": [
            2,
            3,
            4,
            5
          ],
          "details": "Develop refresh buttons or automatic update triggers to recalculate all dashboard components. Implement timestamp indicators showing when data was last updated. Create error handling for missing or inconsistent data sources. Test update mechanisms under various scenarios to ensure reliability.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 16,
      "title": "Refactor: 1.1 Adopt a Consistent Modular Architecture",
      "description": "Define and implement a clear folder structure with well-defined responsibilities as outlined in the refactoring plan. This aims to resolve issues of inconsistent code organization, mixed styles, unclear module boundaries, and duplicate functionality.",
      "details": "Current Issues:\n- Inconsistent code organization with mixed styles (classes vs. standalone functions)\n- Unclear module boundaries and responsibilities\n- Duplicate functionality across files\n\nRecommended Changes:\nAdopt a Consistent Modular Architecture by creating a clear folder structure with well-defined responsibilities:\n```\n/\n├── api/                  # API interaction\n│   ├── client.js         # Core API client functionality\n│   ├── endpoints.js      # API endpoint definitions\n│   └── rateLimiter.js    # Rate limiting logic\n├── data/                 # Data processing\n│   ├── processors/       # Data transformation\n│   ├── cache.js          # Caching functionality\n│   └── sheetManager.js   # Sheet interactions\n├── ui/                   # User interface\n│   ├── components/       # Reusable UI components\n│   ├── modals/           # Modal dialogs\n│   └── menu.js           # Menu creation\n├── utils/                # Utilities\n│   ├── logging.js        # Logging functionality\n│   ├── error.js          # Error handling\n│   └── config.js         # Configuration management\n└── main.js               # Entry point\n```",
      "testStrategy": "",
      "status": "pending",
      "dependencies": [],
      "priority": "high",
      "subtasks": [
        {
          "id": 1,
          "title": "Design and Create Folder Structure",
          "description": "Define and implement the new folder structure for the modular architecture",
          "dependencies": [],
          "details": "Create the main module directories (api, data, ui, utils) with appropriate subdirectories. Document the purpose of each directory and establish naming conventions. Create placeholder README files in each directory explaining its purpose and usage guidelines.",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "Implement API Module",
          "description": "Develop the API module with clear interfaces and documentation",
          "dependencies": [
            1
          ],
          "details": "Extract all API-related code into the new structure. Create interface definitions, implement service classes, and establish error handling patterns. Document all endpoints and their usage. Ensure backward compatibility with existing code during transition.",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "Implement Data Processing Module",
          "description": "Develop the data processing module with models and transformers",
          "dependencies": [
            1
          ],
          "details": "Extract all data models, transformers, and processing logic into the data module. Implement clear interfaces between data layer and other modules. Create documentation for data flows and model relationships. Establish patterns for data validation and transformation.",
          "status": "pending"
        },
        {
          "id": 4,
          "title": "Implement UI Module",
          "description": "Refactor UI components into a modular structure with clear separation of concerns",
          "dependencies": [
            1,
            3
          ],
          "details": "Reorganize UI components into logical groups. Implement component library with consistent patterns. Create clear interfaces between UI and data/API layers. Document component usage and establish style guidelines. Ensure responsive design principles are maintained.",
          "status": "pending"
        },
        {
          "id": 5,
          "title": "Implement Utilities Module",
          "description": "Create a shared utilities module for common functionality",
          "dependencies": [
            1
          ],
          "details": "Extract all utility functions into appropriate categories (string manipulation, date handling, etc.). Implement comprehensive unit tests for all utility functions. Create documentation with examples for each utility. Ensure utilities are pure functions where possible.",
          "status": "pending"
        },
        {
          "id": 6,
          "title": "Refactor Application Entry Points",
          "description": "Update main entry points to use the new modular architecture",
          "dependencies": [
            2,
            3,
            4,
            5
          ],
          "details": "Refactor main application entry points to import and use the new modular structure. Implement dependency injection patterns if applicable. Update initialization sequence to respect module dependencies. Create comprehensive integration tests to verify correct operation.",
          "status": "pending"
        },
        {
          "id": 7,
          "title": "Create and Execute Migration Plan",
          "description": "Develop and implement a phased migration plan for existing code",
          "dependencies": [
            6
          ],
          "details": "Create a detailed migration plan with phases and milestones. Identify high-risk areas requiring special attention. Implement feature flags to enable gradual transition. Develop comprehensive testing strategy for each migration phase. Document legacy code patterns and their modern replacements.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 17,
      "title": "Refactor: 1.2 Convert to Consistent Class-Based Architecture",
      "description": "Refactor existing code and implement new features using a consistent class-based architecture. This will improve code organization, encapsulation, and maintainability.",
      "details": "Current Issues:\n- Inconsistent code organization with mixed styles (classes vs. standalone functions)\n\nRecommended Changes:\nConvert to Consistent Class-Based Architecture. Example:\n```javascript\n/**\n * ApiClient class to encapsulate all API interactions.\n */\nclass ApiClient {\n  constructor(config) {\n    this.baseUrl = config.baseUrl;\n    this.apiKey = config.apiKey;\n    this.rateLimiter = new RateLimiter(config.rateLimits);\n  }\n\n  async request(endpoint, params = {}) {\n    const url = this.buildUrl(endpoint, params);\n    const canProceed = this.rateLimiter.canProceed(endpoint);\n    \n    if (!canProceed.proceed) {\n      await this.wait(canProceed.waitTime);\n    }\n    \n    return this.makeRequest(url);\n  }\n  \n  // Other methods...\n}\n```",
      "testStrategy": "",
      "status": "pending",
      "dependencies": [
        16
      ],
      "priority": "high",
      "subtasks": [
        {
          "id": 1,
          "title": "Design Core Service Classes",
          "description": "Create a comprehensive design for core service classes that will form the foundation of the refactored architecture",
          "dependencies": [],
          "details": "Identify all core services in the current codebase. Create UML diagrams showing class relationships, inheritance hierarchies, and interfaces. Define clear responsibilities, methods, and properties for each service class. Ensure proper encapsulation and separation of concerns. Consider performance implications and potential optimization opportunities.",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "Implement Data Model Classes",
          "description": "Convert existing data structures into proper class-based data models with appropriate methods and properties",
          "dependencies": [
            1
          ],
          "details": "Analyze current data structures and their usage patterns. Design data model classes with appropriate validation, serialization, and type safety. Implement getters/setters and data transformation methods. Ensure backward compatibility with existing code. Add unit tests for each data model class to verify behavior.",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "Convert UI Components to Classes",
          "description": "Refactor UI components into class-based architecture with proper inheritance and composition",
          "dependencies": [
            1,
            2
          ],
          "details": "Identify all UI components requiring conversion. Create base component classes and inheritance hierarchies. Implement lifecycle methods, event handling, and state management within the class structure. Ensure rendering logic is properly encapsulated. Test each component individually to verify visual and functional correctness.",
          "status": "pending"
        },
        {
          "id": 4,
          "title": "Create Utility Classes",
          "description": "Refactor utility functions into organized utility classes with static methods and proper namespacing",
          "dependencies": [
            1
          ],
          "details": "Categorize existing utility functions by domain and purpose. Design utility classes with logical grouping and clear naming conventions. Convert functions to static class methods with improved type safety. Add comprehensive JSDoc documentation. Create unit tests for all utility methods to ensure functionality is preserved.",
          "status": "pending"
        },
        {
          "id": 5,
          "title": "Perform Integration Testing",
          "description": "Conduct thorough integration testing to ensure all refactored classes work together correctly",
          "dependencies": [
            2,
            3,
            4
          ],
          "details": "Create integration test suites covering interactions between refactored components. Test all critical user flows and edge cases. Verify performance metrics against pre-refactoring baseline. Address any integration issues or regressions. Update existing automated tests to work with the new class structure.",
          "status": "pending"
        },
        {
          "id": 6,
          "title": "Document Class Architecture",
          "description": "Create comprehensive documentation for the new class-based architecture",
          "dependencies": [
            1,
            2,
            3,
            4,
            5
          ],
          "details": "Generate class diagrams showing the complete architecture. Document design patterns and architectural decisions. Create usage examples for key classes. Document extension points and customization options. Update developer onboarding materials with new architecture information. Include migration guides for any code that needs to be updated by other teams.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 18,
      "title": "Refactor: 2.1 Implement Singleton Pattern for Service Classes",
      "description": "Implement the Singleton design pattern for service classes like ApiClient to ensure a single instance is used throughout the application. This will help manage shared resources and state.",
      "details": "Current Issues:\n- Lack of consistent design patterns\n- Mixed approach to similar problems\n\nRecommended Changes:\nImplement Singleton Pattern for Service Classes. Example:\n```javascript\n/**\n * Singleton pattern for ApiClient.\n */\nclass ApiClient {\n  static instance;\n  \n  static getInstance(config) {\n    if (!ApiClient.instance) {\n      ApiClient.instance = new ApiClient(config);\n    }\n    return ApiClient.instance;\n  }\n  \n  // Rest of the class implementation...\n}\n```",
      "testStrategy": "",
      "status": "pending",
      "dependencies": [
        17
      ],
      "priority": "medium",
      "subtasks": [
        {
          "id": 1,
          "title": "Design singleton pattern for core service classes",
          "description": "Create the basic structure for implementing the singleton pattern in core service classes",
          "dependencies": [],
          "details": "1. Identify all core service classes that need to be singletons\n2. Modify each class to have a private constructor\n3. Add a private static instance variable to each class\n4. Create a public static getInstance() method for each class\n5. Document the singleton implementation with appropriate comments",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "Implement instance management and initialization logic",
          "description": "Develop the logic for managing singleton instances and handling initialization",
          "dependencies": [
            1
          ],
          "details": "1. Implement thread-safe instance creation (using double-checked locking or other appropriate method)\n2. Add lazy initialization to defer object creation until needed\n3. Handle any required initialization parameters for service instances\n4. Implement proper resource cleanup if needed (e.g., in case of application shutdown)\n5. Add error handling for initialization failures",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "Integrate singleton services with existing code",
          "description": "Update existing code to use the singleton pattern for accessing service instances",
          "dependencies": [
            2
          ],
          "details": "1. Identify all locations in the codebase that create or use service instances\n2. Replace direct instantiation with calls to getInstance()\n3. Update any dependency injection configurations if applicable\n4. Write unit tests to verify singleton behavior\n5. Perform integration testing to ensure services function correctly with the new pattern",
          "status": "pending"
        }
      ]
    },
    {
      "id": 19,
      "title": "Refactor: 2.2 Use Factory Pattern for Sheet Creation",
      "description": "Implement the Factory design pattern for creating different types of Google Sheets. This will centralize sheet creation logic and make it easier to add new sheet types.",
      "details": "Current Issues:\n- Lack of consistent design patterns\n- Mixed approach to similar problems\n\nRecommended Changes:\nUse Factory Pattern for Sheet Creation. Example:\n```javascript\n/**\n * Factory for creating different types of sheets.\n */\nclass SheetFactory {\n  static createSheet(type, name) {\n    switch (type) {\n      case 'account':\n        return new AccountSheet(name);\n      case 'transactions':\n        return new TransactionsSheet(name);\n      case 'pies':\n        return new PiesSheet(name);\n      default:\n        return new BaseSheet(name);\n    }\n  }\n}\n```",
      "testStrategy": "",
      "status": "pending",
      "dependencies": [
        17
      ],
      "priority": "medium",
      "subtasks": [
        {
          "id": 1,
          "title": "Design Sheet Factory Class",
          "description": "Create the SheetFactory class that will handle the creation of different sheet types",
          "dependencies": [],
          "details": "Design and implement the SheetFactory class with a createSheet method that accepts parameters to determine which type of sheet to create. Include appropriate interfaces or abstract classes as needed. Document the factory's public API and ensure it follows SOLID principles.",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "Implement Sheet Type Class Hierarchy",
          "description": "Create the necessary sheet type classes with a common interface or base class",
          "dependencies": [
            1
          ],
          "details": "Define a common interface or abstract base class for all sheet types. Implement concrete sheet classes for each type of sheet needed. Ensure each sheet type implements the required methods and properties. Document the relationships between classes in the hierarchy.",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "Integrate Factory with Existing Code",
          "description": "Refactor existing sheet creation code to use the new factory pattern",
          "dependencies": [
            1,
            2
          ],
          "details": "Identify all locations in the codebase where sheets are currently created. Replace direct instantiation with calls to the SheetFactory. Update any dependent code that might be affected by the new sheet class hierarchy. Ensure backward compatibility where needed.",
          "status": "pending"
        },
        {
          "id": 4,
          "title": "Test Factory Pattern Implementation",
          "description": "Create unit and integration tests for the factory pattern functionality",
          "dependencies": [
            1,
            2,
            3
          ],
          "details": "Write unit tests for the SheetFactory class and each sheet type. Create integration tests to verify the factory works correctly with the rest of the application. Test edge cases and error handling. Verify that all existing functionality continues to work with the new implementation.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 20,
      "title": "Refactor: 2.3 Implement Observer Pattern for UI Updates",
      "description": "Implement the Observer design pattern for managing UI updates. This will decouple UI components from data sources and allow for more flexible and maintainable UI logic.",
      "details": "Current Issues:\n- Lack of consistent design patterns\n- Mixed approach to similar problems\n\nRecommended Changes:\nImplement Observer Pattern for UI Updates. Example:\n```javascript\n/**\n * Observer pattern for UI updates.\n */\nclass EventEmitter {\n  constructor() {\n    this.events = {};\n  }\n  \n  on(event, listener) {\n    if (!this.events[event]) {\n      this.events[event] = [];\n    }\n    this.events[event].push(listener);\n  }\n  \n  emit(event, data) {\n    if (this.events[event]) {\n      this.events[event].forEach(listener => listener(data));\n    }\n  }\n}\n```",
      "testStrategy": "",
      "status": "pending",
      "dependencies": [
        17
      ],
      "priority": "medium",
      "subtasks": [
        {
          "id": 1,
          "title": "Design and implement the EventEmitter class",
          "description": "Create a core EventEmitter class that will manage subscriptions and event dispatching",
          "dependencies": [],
          "details": "Implement a class that provides methods for subscribing to events (on/addEventListener), unsubscribing (off/removeEventListener), and emitting events (emit/dispatchEvent). Include support for event namespacing, multiple listeners per event, and proper memory management for removing listeners. Document the API with clear examples.",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "Implement Observable component base class",
          "description": "Create a base class or mixin that UI components can extend to become observable",
          "dependencies": [
            1
          ],
          "details": "Build an Observable class or mixin that utilizes the EventEmitter to expose a consistent interface for UI components. Include methods for state changes that automatically trigger appropriate events. Define standard event types and naming conventions. Ensure proper inheritance patterns for existing component hierarchies.",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "Implement Observer pattern in UI components",
          "description": "Modify UI components to observe and react to events from observable components",
          "dependencies": [
            2
          ],
          "details": "Update UI components to subscribe to events from observable components. Implement handler methods that update the UI in response to state changes. Ensure proper lifecycle management (subscribing when mounted, unsubscribing when unmounted). Create helper methods for common observation patterns.",
          "status": "pending"
        },
        {
          "id": 4,
          "title": "Integrate with existing UI update code",
          "description": "Refactor existing UI update mechanisms to use the new observer pattern",
          "dependencies": [
            3
          ],
          "details": "Identify all places in the codebase where direct UI updates occur. Replace imperative update calls with the observer pattern. Ensure backward compatibility during transition. Update documentation to reflect the new pattern. Verify that all UI components receive updates appropriately.",
          "status": "pending"
        },
        {
          "id": 5,
          "title": "Test observer pattern implementation",
          "description": "Create comprehensive tests for the observer pattern implementation",
          "dependencies": [
            4
          ],
          "details": "Write unit tests for the EventEmitter and Observable classes. Create integration tests for observer-observable component pairs. Test edge cases like multiple observers, observer removal, and complex event chains. Implement performance tests to ensure the pattern doesn't introduce significant overhead. Document testing approach and results.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 21,
      "title": "Refactor: 3.1 Centralize API Configuration",
      "description": "Create a single, centralized configuration file for all API-related constants, such as base URLs, endpoints, and rate limits. This will improve maintainability and make it easier to update API settings.",
      "details": "Current Issues:\n- Inconsistent API request handling\n- Duplicate API call functions\n- Limited rate limiting implementation\n\nRecommended Changes:\nCentralize API Configuration. Create a single config file for all API-related constants:\n```javascript\n/**\n * Centralized API configuration.\n */\nconst API_CONFIG = {\n  domains: {\n    live: 'https://live.trading212.com',\n    demo: 'https://demo.trading212.com'\n  },\n  version: '/api/v0/',\n  endpoints: {\n    pies: 'equity/pies',\n    accountInfo: 'equity/account/info',\n    // Other endpoints...\n  },\n  rateLimits: {\n    'equity/pies': { limit: 1, windowMs: 30000 },\n    // Other rate limits...\n  }\n};\n```",
      "testStrategy": "",
      "status": "pending",
      "dependencies": [
        16
      ],
      "priority": "high",
      "subtasks": [
        {
          "id": 1,
          "title": "Design API Configuration Structure",
          "description": "Create a standardized structure for centralized API configuration",
          "dependencies": [],
          "details": "Define a clear, maintainable structure for API configuration that includes endpoints, authentication methods, headers, and other common parameters. Consider using a hierarchical structure that groups related APIs. Document the structure with examples for team reference.",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "Extract Existing API Configuration",
          "description": "Identify and extract all API configuration from current codebase",
          "dependencies": [
            1
          ],
          "details": "Scan the codebase to identify all instances of API configuration. Extract endpoint URLs, headers, authentication details, and other configuration parameters. Consolidate these into the new centralized structure defined in the previous subtask. Document any inconsistencies found during extraction.",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "Integrate with API Client Code",
          "description": "Update API client code to use the centralized configuration",
          "dependencies": [
            1,
            2
          ],
          "details": "Modify existing API client code to reference the centralized configuration instead of hardcoded values. Create helper functions or methods to easily access the configuration. Test all API calls to ensure they work correctly with the new configuration approach. Update documentation to reflect the new pattern for API configuration usage.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 22,
      "title": "Refactor: 3.2 Create a Unified API Client",
      "description": "Develop a unified API client class (e.g., Trading212ApiClient) to handle all interactions with the Trading212 API. This client should use the centralized API configuration and incorporate rate limiting.",
      "details": "Current Issues:\n- Inconsistent API request handling\n- Duplicate API call functions\n\nRecommended Changes:\nCreate a Unified API Client. Example:\n```javascript\n/**\n * Unified API client for all Trading212 API interactions.\n */\nclass Trading212ApiClient {\n  constructor(environment = 'demo') {\n    this.domain = API_CONFIG.domains[environment];\n    this.baseUrl = `${this.domain}${API_CONFIG.version}`;\n    this.rateLimiter = new RateLimiter(API_CONFIG.rateLimits);\n  }\n  \n  async get(endpoint, params = {}) {\n    const url = this.buildUrl(endpoint, params);\n    const rateLimitStatus = this.rateLimiter.canProceed(endpoint);\n    \n    if (!rateLimitStatus.proceed) {\n      await new Promise(resolve => setTimeout(resolve, rateLimitStatus.waitTime));\n    }\n    \n    return this.fetchWithAuth(url);\n  }\n  \n  // Other methods...\n}\n```",
      "testStrategy": "",
      "status": "pending",
      "dependencies": [
        17,
        21
      ],
      "priority": "high",
      "subtasks": [
        {
          "id": 1,
          "title": "Design API client class structure",
          "description": "Create the architecture and class hierarchy for the unified API client",
          "dependencies": [],
          "details": "Define the core API client class with appropriate interfaces, abstract classes, and inheritance patterns. Include method signatures for common operations, error handling strategies, and configuration options. Create UML diagrams to visualize the class relationships. Consider extensibility for future API endpoints and backward compatibility requirements.",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "Implement request handling functionality",
          "description": "Build the core request/response handling mechanisms in the API client",
          "dependencies": [
            1
          ],
          "details": "Implement methods for different HTTP verbs (GET, POST, PUT, DELETE), request serialization, response deserialization, and error handling. Include support for different content types, query parameters, request headers, and response parsing. Implement retry logic for failed requests and timeout handling. Add comprehensive logging for debugging purposes.",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "Integrate authentication mechanisms",
          "description": "Add support for various authentication methods in the API client",
          "dependencies": [
            2
          ],
          "details": "Implement authentication strategies including API keys, OAuth, JWT, and session-based authentication. Create interceptors or middleware to automatically apply authentication to requests. Handle token refresh, expiration, and storage. Implement secure credential management and ensure authentication errors are properly handled and reported.",
          "status": "pending"
        },
        {
          "id": 4,
          "title": "Implement rate limiting functionality",
          "description": "Add rate limiting support to prevent API quota exhaustion",
          "dependencies": [
            2
          ],
          "details": "Create rate limiting mechanisms that respect API provider limits. Implement request queuing, throttling, and backoff strategies. Add monitoring for remaining quota and rate limit headers. Implement circuit breakers to prevent cascading failures during rate limit exhaustion. Ensure the client can handle 429 responses appropriately with automatic retries after the specified cooldown period.",
          "status": "pending"
        },
        {
          "id": 5,
          "title": "Migrate existing API calls to the new client",
          "description": "Update all existing API interactions to use the new unified client",
          "dependencies": [
            1,
            2,
            3,
            4
          ],
          "details": "Identify all existing API calls throughout the codebase. Create a migration plan with priority order. Refactor each API call to use the new client while maintaining existing functionality. Write tests to ensure behavior remains consistent. Update documentation to reflect the new API client usage patterns. Monitor performance and error rates after migration to ensure improvement.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 23,
      "title": "Refactor: 3.3 Implement Robust Rate Limiting",
      "description": "Enhance the RateLimiter class to include robust strategies for handling API rate limits, such as backoff and retry mechanisms. This will make API interactions more resilient.",
      "details": "Current Issues:\n- Limited rate limiting implementation\n\nRecommended Changes:\nImplement Robust Rate Limiting. Enhance the RateLimiter class to handle backoff and retry strategies:\n```javascript\n/**\n * Enhanced rate limiter with backoff and retry strategies.\n */\nclass RateLimiter {\n  constructor(rateLimits) {\n    this.rateLimits = rateLimits;\n    this.requestLogs = {};\n  }\n  \n  canProceed(endpoint) {\n    // Current implementation...\n  }\n  \n  async executeWithRateLimit(endpoint, func) {\n    const status = this.canProceed(endpoint);\n    \n    if (status.proceed) {\n      return func();\n    } else {\n      await new Promise(resolve => setTimeout(resolve, status.waitTime));\n      return this.executeWithRateLimit(endpoint, func);\n    }\n  }\n}\n```",
      "testStrategy": "",
      "status": "pending",
      "dependencies": [
        17,
        21
      ],
      "priority": "high",
      "subtasks": [
        {
          "id": 1,
          "title": "Design Rate Limiter Class",
          "description": "Create a rate limiter class with configurable request limits and time windows",
          "dependencies": [],
          "details": "Design and implement a RateLimiter class that tracks API requests and enforces configurable rate limits. Include methods to check if a request is allowed, track request timestamps, and calculate remaining quota. The class should support different time windows (per second, minute, hour) and maintain request history.",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "Implement Backoff Strategy",
          "description": "Create algorithms for exponential and linear backoff with jitter",
          "dependencies": [
            1
          ],
          "details": "Implement backoff strategy algorithms including exponential backoff with configurable base and maximum delay, linear backoff, and random jitter to prevent thundering herd problems. Create a BackoffStrategy interface and concrete implementations for different backoff approaches. Include methods to calculate wait times based on retry attempts.",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "Develop Retry Mechanism",
          "description": "Build a retry handler that works with the rate limiter and backoff strategy",
          "dependencies": [
            1,
            2
          ],
          "details": "Create a RetryHandler class that integrates with the rate limiter and backoff strategy. Implement logic to detect rate limit errors (429 responses), network failures, and other retryable errors. Include configurable maximum retry attempts, timeout handling, and logging of retry attempts. The handler should apply appropriate backoff delays between retries.",
          "status": "pending"
        },
        {
          "id": 4,
          "title": "Integrate with API Client",
          "description": "Connect rate limiting components with the API client for seamless operation",
          "dependencies": [
            1,
            2,
            3
          ],
          "details": "Integrate the rate limiter, backoff strategy, and retry mechanism with the API client. Modify the API client to use these components for all requests. Implement proper error handling and response processing. Add configuration options to the API client for rate limits, retry attempts, and backoff strategies. Test the integrated solution with various API endpoints and rate limit scenarios.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 24,
      "title": "Refactor: 4.1 Create Data Model Classes",
      "description": "Develop data model classes (e.g., BaseModel, PieModel) to represent data entities fetched from the API. These classes should encapsulate data processing logic and provide methods for converting data to sheet rows.",
      "details": "Current Issues:\n- Complex data transformation logic\n- Inconsistent sheet updating approach\n\nRecommended Changes:\nCreate Data Model Classes. Example:\n```javascript\n/**\n * Base model class for data entities.\n */\nclass BaseModel {\n  constructor(data) {\n    this.rawData = data;\n    this.processData();\n  }\n  \n  processData() {\n    // Default implementation\n  }\n  \n  toSheetRow() {\n    // Convert to array for sheet row\n  }\n}\n\n/**\n * Pie model for investment pies.\n */\nclass PieModel extends BaseModel {\n  processData() {\n    this.id = this.rawData.id;\n    this.name = this.rawData.name;\n    this.value = this.rawData.value;\n    this.items = (this.rawData.items || []).map(item => new PieItemModel(item));\n  }\n  \n  toSheetRow() {\n    return [\n      this.id,\n      this.name,\n      this.value,\n      this.items.map(item => item.name).join(', ')\n    ];\n  }\n}\n```",
      "testStrategy": "",
      "status": "pending",
      "dependencies": [
        17
      ],
      "priority": "high",
      "subtasks": [
        {
          "id": 1,
          "title": "Design Base Model Class",
          "description": "Create an abstract base model class that defines common properties and methods for all data entities",
          "dependencies": [],
          "details": "Implement a BaseModel class that includes: common attributes (ID, timestamps, etc.), serialization/deserialization methods, validation logic, and interfaces for data operations. Consider using inheritance patterns and define abstract methods that child classes must implement.",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "Implement Specific Model Classes",
          "description": "Create concrete model classes for each data type that inherit from the base model",
          "dependencies": [
            1
          ],
          "details": "For each entity type from the API (e.g., User, Product, Order), create a specific model class that extends BaseModel. Define entity-specific properties, override necessary methods, and implement type-specific validation rules. Ensure proper typing and documentation for each class.",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "Develop Data Processing Methods",
          "description": "Implement methods for data transformation, filtering, and aggregation in each model class",
          "dependencies": [
            2
          ],
          "details": "Add methods to handle data processing operations like filtering records, transforming data formats, calculating derived values, and aggregating information. Include utility methods for common operations and ensure consistent error handling across all processing methods.",
          "status": "pending"
        },
        {
          "id": 4,
          "title": "Create Sheet Conversion Methods",
          "description": "Implement methods to convert model data to and from spreadsheet formats",
          "dependencies": [
            3
          ],
          "details": "Add functionality to transform model instances to row/column format for spreadsheets and vice versa. Include header generation, data type conversion, formula handling, and methods to batch process multiple records. Ensure proper handling of special characters and formatting options.",
          "status": "pending"
        },
        {
          "id": 5,
          "title": "Integrate with Existing Data Handling Code",
          "description": "Connect the new model classes with existing data fetching and storage mechanisms",
          "dependencies": [
            4
          ],
          "details": "Refactor existing data handling code to use the new model classes. Update API service classes to return model instances, modify storage utilities to accept models, and ensure UI components can consume the model data. Write tests to verify proper integration and data flow through the system.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 25,
      "title": "Refactor: 4.2 Implement Repository Pattern for Data Access",
      "description": "Implement the Repository design pattern for data access and management. Create repository classes (e.g., BaseRepository, PiesRepository) to abstract data source interactions (API, sheets) and manage data models.",
      "details": "Current Issues:\n- Complex data transformation logic\n- Inconsistent sheet updating approach\n\nRecommended Changes:\nImplement Repository Pattern for Data Access. Example:\n```javascript\n/**\n * Base repository class for data access.\n */\nclass BaseRepository {\n  constructor(sheetName) {\n    this.sheetName = sheetName;\n    this.sheet = this.getOrCreateSheet();\n  }\n  \n  getOrCreateSheet() {\n    // Implementation...\n  }\n  \n  save(models) {\n    // Implementation...\n  }\n}\n\n/**\n * Pies repository for pie data management.\n */\nclass PiesRepository extends BaseRepository {\n  async fetchAll() {\n    const apiClient = ApiClient.getInstance();\n    const data = await apiClient.get('equity/pies');\n    return data.items.map(item => new PieModel(item));\n  }\n  \n  saveAll(pies) {\n    const headers = ['ID', 'Name', 'Value', 'Items'];\n    const rows = pies.map(pie => pie.toSheetRow());\n    super.writeData(headers, rows);\n  }\n}\n```",
      "testStrategy": "",
      "status": "pending",
      "dependencies": [
        17,
        18,
        24
      ],
      "priority": "high",
      "subtasks": [
        {
          "id": 1,
          "title": "Design Base Repository Interface and Class",
          "description": "Create the foundation interface and abstract base class for the repository pattern",
          "dependencies": [],
          "details": "Define the IRepository interface with core CRUD methods. Implement a BaseRepository abstract class that will handle common functionality across all repositories. Include error handling, logging, and basic operation templates. Define the contract for data access operations that all specific repositories will implement.",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "Implement Specific Repository Classes",
          "description": "Create concrete repository implementations for each data type in the application",
          "dependencies": [
            1
          ],
          "details": "For each entity type (e.g., User, Project, Task), create a dedicated repository class that extends the BaseRepository. Implement type-specific methods and override base methods as needed. Ensure each repository handles the unique requirements of its entity type while maintaining the consistent interface defined by the base repository.",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "Implement Data Fetching Methods",
          "description": "Develop methods for retrieving data from various sources",
          "dependencies": [
            1,
            2
          ],
          "details": "Implement GetById, GetAll, Find, and other query methods in each repository. Create specialized query methods for common access patterns. Handle pagination, filtering, and sorting. Ensure proper error handling and performance optimization for data retrieval operations.",
          "status": "pending"
        },
        {
          "id": 4,
          "title": "Implement Data Saving Methods",
          "description": "Develop methods for creating, updating, and deleting data",
          "dependencies": [
            1,
            2
          ],
          "details": "Implement Create, Update, Delete, and SaveChanges methods in each repository. Ensure data validation before persistence. Implement transaction support for operations that affect multiple entities. Add optimistic concurrency control where appropriate to prevent data conflicts.",
          "status": "pending"
        },
        {
          "id": 5,
          "title": "Integrate Caching Mechanism",
          "description": "Add caching support to the repository pattern implementation",
          "dependencies": [
            3,
            4
          ],
          "details": "Design and implement a caching strategy for frequently accessed data. Add cache invalidation logic for data modifications. Implement configurable cache duration and policies. Create a cache manager that can be injected into repositories. Ensure thread-safety for cache operations in a multi-user environment.",
          "status": "pending"
        },
        {
          "id": 6,
          "title": "Migrate Existing Data Access Code",
          "description": "Refactor current data access code to use the new repository pattern",
          "dependencies": [
            2,
            3,
            4,
            5
          ],
          "details": "Identify all existing data access code throughout the application. Systematically replace direct data access with repository calls. Update dependency injection configuration to provide repositories. Write tests to verify the migration was successful. Document any API changes for other developers.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 26,
      "title": "Refactor: 4.3 Enhanced Caching Strategy",
      "description": "Implement an enhanced caching service with TTL (Time-To-Live) and invalidation mechanisms to improve performance and reduce API calls. This will make the application more responsive and reduce the risk of hitting API rate limits.",
      "details": "Current Issues:\n- Limited caching strategy\n\nRecommended Changes:\nEnhanced Caching Strategy. Example:\n```javascript\n/**\n * Enhanced caching service with TTL and invalidation.\n */\nclass CacheService {\n  constructor() {\n    this.cache = CacheService.getScriptCache();\n  }\n  \n  get(key) {\n    const data = this.cache.get(key);\n    return data ? JSON.parse(data) : null;\n  }\n  \n  set(key, data, ttl = 600) { // Default 10 minutes\n    this.cache.put(key, JSON.stringify(data), ttl);\n  }\n  \n  invalidate(key) {\n    this.cache.remove(key);\n  }\n  \n  invalidateByPrefix(prefix) {\n    // Implementation to invalidate keys by prefix\n  }\n}\n```",
      "testStrategy": "",
      "status": "pending",
      "dependencies": [
        17
      ],
      "priority": "medium",
      "subtasks": [
        {
          "id": 1,
          "title": "Design and implement cache service class",
          "description": "Create a cache service class with core functionality for storing and retrieving data",
          "dependencies": [],
          "details": "Design a flexible cache service class that supports different data types. Implement methods for get(), set(), has(), and delete() operations. Include support for serialization/deserialization of complex objects. Define appropriate interfaces and implement concrete cache provider (memory-based initially).",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "Implement TTL (Time-To-Live) mechanism",
          "description": "Add expiration functionality to the cache service",
          "dependencies": [
            1
          ],
          "details": "Extend the cache service to support TTL for cached items. Implement timestamp tracking for each cached item. Create a mechanism to check expiration during retrieval. Add automatic cleanup of expired items (either on-demand or via background process). Include configurable default TTL values.",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "Develop cache invalidation methods",
          "description": "Create strategies for invalidating cache entries based on different scenarios",
          "dependencies": [
            1,
            2
          ],
          "details": "Implement pattern-based cache invalidation (e.g., by key prefix). Add support for bulk invalidation operations. Create event-based invalidation triggers for data changes. Develop cache dependencies to allow related items to be invalidated together. Include logging for cache invalidation events for debugging.",
          "status": "pending"
        },
        {
          "id": 4,
          "title": "Integrate caching with repository classes",
          "description": "Modify repository classes to utilize the cache service",
          "dependencies": [
            1,
            2,
            3
          ],
          "details": "Create a caching decorator or wrapper for repository classes. Implement cache-aside pattern (check cache first, then database). Add cache population on database reads. Ensure cache invalidation on writes/updates/deletes. Add configuration options to enable/disable caching per repository or method. Create unit tests to verify correct caching behavior.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 27,
      "title": "Refactor: 5.1 Create a UI Controller",
      "description": "Develop a dedicated UI controller class to manage user interface interactions, such as showing modals and handling UI events. This will centralize UI logic and improve code organization.",
      "details": "Current Issues:\n- Complex UI initialization\n- Limited feedback mechanisms\n- Inconsistent UI handling\n\nRecommended Changes:\nCreate a UI Controller. Example:\n```javascript\n/**\n * Controller for UI management.\n */\nclass UiController {\n  constructor() {\n    this.eventEmitter = new EventEmitter();\n  }\n  \n  showModal(templateName, title, options = {}) {\n    const html = this.createModalHtml(templateName, options);\n    SpreadsheetApp.getUi().showModalDialog(html, title);\n  }\n  \n  createModalHtml(templateName, options) {\n    // Implementation...\n  }\n  \n  // Other methods...\n}\n```",
      "testStrategy": "",
      "status": "pending",
      "dependencies": [
        17,
        20
      ],
      "priority": "medium",
      "subtasks": [
        {
          "id": 1,
          "title": "Design UI Controller Class Architecture",
          "description": "Create the architecture for the UI controller class including interface definition, core methods, and integration points with the application.",
          "dependencies": [],
          "details": "Define the UI controller class structure with proper inheritance hierarchy. Identify all required public methods, private methods, and properties. Create UML diagrams showing relationships with other components. Document the controller's responsibilities and boundaries. Include initialization sequence and lifecycle management.",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "Implement Modal Dialog Management",
          "description": "Develop the modal dialog management functionality within the UI controller to handle opening, closing, and state management of modal dialogs.",
          "dependencies": [
            1
          ],
          "details": "Create methods for opening and closing modal dialogs. Implement z-index management for multiple dialogs. Add support for modal backdrop handling. Develop dialog animation and transition effects. Create dialog state tracking system. Implement methods to handle dialog content loading and unloading.",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "Integrate Event Handling System",
          "description": "Implement the event handling system in the UI controller to manage user interactions and UI events throughout the application.",
          "dependencies": [
            1
          ],
          "details": "Create event listener registration and management system. Implement event delegation patterns for efficiency. Develop custom event types for UI-specific interactions. Add support for keyboard shortcuts and accessibility events. Create documentation for event naming conventions and usage patterns. Implement event bubbling and capturing logic.",
          "status": "pending"
        },
        {
          "id": 4,
          "title": "Develop UI State Management System",
          "description": "Create a comprehensive state management system within the UI controller to track and update UI component states.",
          "dependencies": [
            1,
            3
          ],
          "details": "Implement state object structure with proper immutability patterns. Create state change notification system. Develop methods for component state retrieval and updates. Add support for state history and undo/redo functionality. Implement state persistence for page reloads. Create debugging tools for state inspection.",
          "status": "pending"
        },
        {
          "id": 5,
          "title": "Migrate Existing UI Code to New Controller",
          "description": "Refactor and migrate existing UI code to use the new UI controller architecture.",
          "dependencies": [
            1,
            2,
            3,
            4
          ],
          "details": "Identify all existing UI code that needs migration. Create migration plan with priority order. Refactor code to use new controller methods and patterns. Update event handlers to use new event system. Migrate state management to new state system. Perform regression testing on migrated components. Document any breaking changes and required updates for other developers.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 28,
      "title": "Refactor: 5.2 Implement a Loading State Manager",
      "description": "Implement a loading state manager to provide clear feedback to the user during data fetching or processing operations. This will improve the user experience by indicating when the application is busy.",
      "details": "Current Issues:\n- Limited feedback mechanisms\n- Inconsistent UI handling\n\nRecommended Changes:\nImplement a Loading State Manager. Example:\n```javascript\n/**\n * Loading state manager for UI feedback.\n */\nclass LoadingManager {\n  constructor() {\n    this.loadingStates = {};\n  }\n  \n  setLoading(id, isLoading) {\n    this.loadingStates[id] = isLoading;\n    this.updateUi(id);\n  }\n  \n  updateUi(id) {\n    // Implementation to update UI based on loading state\n  }\n}\n```",
      "testStrategy": "",
      "status": "pending",
      "dependencies": [
        17,
        27
      ],
      "priority": "medium",
      "subtasks": [
        {
          "id": 1,
          "title": "Design Loading Manager Class",
          "description": "Create a class to manage loading states across the application",
          "dependencies": [],
          "details": "Design and implement a LoadingManager class that can track multiple loading operations simultaneously. Include methods for starting/stopping loading states with unique identifiers, checking if any loading is in progress, and maintaining a registry of active loading operations. Consider using a singleton pattern for global access.",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "Implement UI Update Methods",
          "description": "Create methods to update UI elements based on loading states",
          "dependencies": [
            1
          ],
          "details": "Develop methods that connect the LoadingManager to UI elements. Include functionality to show/hide loading indicators, disable/enable interactive elements during loading, and provide visual feedback. Create both global loading indicators (e.g., overlay spinners) and component-specific loading states (e.g., button spinners). Ensure smooth transitions between states.",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "Integrate with Application Operations",
          "description": "Connect loading manager with operations that require loading indicators",
          "dependencies": [
            1,
            2
          ],
          "details": "Integrate the LoadingManager with API calls, data processing functions, and other operations that benefit from loading indicators. Create utility functions or decorators to easily wrap async operations with loading state management. Implement error handling to ensure loading states are properly cleared even when operations fail.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 29,
      "title": "Refactor: 5.3 Create Reusable UI Components",
      "description": "Develop reusable UI components (e.g., progress indicators, buttons) to ensure consistency and simplify UI development. These components should be modular and easy to integrate.",
      "details": "Current Issues:\n- Complex UI initialization\n- Inconsistent UI handling\n\nRecommended Changes:\nCreate Reusable UI Components. Example:\n```javascript\n/**\n * Function to create a progress indicator component.\n */\nfunction createProgressIndicator(steps, currentStep) {\n  let html = '<div class=\"step-indicator\">';\n  \n  for (let i = 0; i < steps; i++) {\n    html += `<div class=\"step-dot ${i === currentStep ? 'active' : ''}\"></div>`;\n  }\n  \n  html += '</div>';\n  return html;\n}\n```",
      "testStrategy": "",
      "status": "pending",
      "dependencies": [
        16
      ],
      "priority": "medium",
      "subtasks": [
        {
          "id": 1,
          "title": "Component Design and Architecture",
          "description": "Define the overall architecture and design patterns for UI components",
          "dependencies": [],
          "details": "Create a comprehensive component architecture document that outlines component hierarchy, state management approach, and component interfaces. Include component lifecycle considerations, prop structures, and reusability patterns. Document naming conventions and folder structure for the component library.",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "Core UI Component Implementation",
          "description": "Develop the essential UI components like buttons, indicators, form elements, etc.",
          "dependencies": [
            1
          ],
          "details": "Implement the core UI components following the established architecture. Create buttons (primary, secondary, icon buttons), form elements (inputs, checkboxes, radio buttons, dropdowns), indicators (loading spinners, progress bars), and other fundamental components. Ensure components are accessible and follow best practices for keyboard navigation and screen readers.",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "Component Styling and Theming",
          "description": "Implement consistent styling and theming system for all components",
          "dependencies": [
            2
          ],
          "details": "Develop a theming system that allows for consistent styling across components. Create a design token system for colors, typography, spacing, and other visual properties. Implement light/dark mode support and ensure components respond appropriately to theme changes. Document the styling approach and provide examples of theme customization.",
          "status": "pending"
        },
        {
          "id": 4,
          "title": "Integration with Existing UI Code",
          "description": "Integrate the new component library with the existing UI codebase",
          "dependencies": [
            3
          ],
          "details": "Replace existing UI elements with the new component library systematically. Create migration guides for developers to adopt the new components. Implement any necessary adapter patterns to ensure backward compatibility. Test the integration thoroughly across different parts of the application to ensure visual consistency and functionality.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 30,
      "title": "Refactor: 6.1 Create a Centralized Error Handler",
      "description": "Develop a centralized error handler class to manage errors consistently throughout the application. This handler should log errors, determine error types, and trigger appropriate actions.",
      "details": "Current Issues:\n- Inconsistent error handling\n- Limited user feedback for errors\n- Unclear error recovery strategies\n\nRecommended Changes:\nCreate a Centralized Error Handler. Example:\n```javascript\n/**\n * Centralized error handler for consistent error management.\n */\nclass ErrorHandler {\n  static handle(error, context = {}) {\n    Logger.log(`Error in ${context.location || 'unknown'}: ${error.message}`);\n    \n    // Determine error type and action\n    if (error.name === 'ApiError') {\n      return ErrorHandler.handleApiError(error, context);\n    } else if (error.name === 'ValidationError') {\n      return ErrorHandler.handleValidationError(error, context);\n    } else {\n      return ErrorHandler.handleGenericError(error, context);\n    }\n  }\n  \n  static handleApiError(error, context) {\n    // Handle API-specific errors\n  }\n  \n  static handleValidationError(error, context) {\n    // Handle validation errors\n  }\n  \n  static handleGenericError(error, context) {\n    // Handle generic errors\n  }\n}\n```",
      "testStrategy": "",
      "status": "pending",
      "dependencies": [
        16
      ],
      "priority": "high",
      "subtasks": [
        {
          "id": 1,
          "title": "Design Error Handler Class Structure",
          "description": "Create the core error handler class with appropriate methods and properties",
          "dependencies": [],
          "details": "Design a centralized ErrorHandler class with a clear interface. Include methods for handling different error severities, error registration, and error processing. Define the class structure, inheritance hierarchy if needed, and core interfaces. Consider making it a singleton or using dependency injection for global access.",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "Implement Error Type Classification Logic",
          "description": "Develop logic to categorize errors by type, severity, and source",
          "dependencies": [
            1
          ],
          "details": "Create a classification system that categorizes errors by type (validation, network, database, etc.), severity (critical, warning, info), and source. Implement logic to determine error priority and required action based on classification. Include extensible mechanisms to add new error types in the future.",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "Develop Error Logging Implementation",
          "description": "Create comprehensive logging functionality for all error types",
          "dependencies": [
            1,
            2
          ],
          "details": "Implement logging mechanisms that record detailed error information including stack traces, context data, and classification details. Support multiple output destinations (console, file, external service). Include formatting options and ensure sensitive data is properly masked. Add rotation and retention policies for log files.",
          "status": "pending"
        },
        {
          "id": 4,
          "title": "Design Error Recovery Strategies",
          "description": "Implement recovery mechanisms for different error scenarios",
          "dependencies": [
            2
          ],
          "details": "Develop strategies for automatic recovery from non-critical errors. Implement retry mechanisms with exponential backoff for transient failures. Create fallback procedures for critical components. Design circuit breaker patterns to prevent cascading failures. Include mechanisms for graceful degradation when services are unavailable.",
          "status": "pending"
        },
        {
          "id": 5,
          "title": "Integrate Error Handler with Application Code",
          "description": "Connect the error handler to the application and document usage patterns",
          "dependencies": [
            1,
            2,
            3,
            4
          ],
          "details": "Create integration points throughout the application to use the centralized error handler. Develop middleware or decorators for automatic error handling in key components. Write documentation and examples showing proper usage patterns. Implement global error catching for unhandled exceptions. Create unit tests demonstrating correct error handling behavior.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 31,
      "title": "Refactor: 6.2 Implement Custom Error Classes",
      "description": "Create custom error classes (e.g., ApiError, ValidationError) to provide more specific information about different types of errors. This will improve error handling and debugging.",
      "details": "Current Issues:\n- Inconsistent error handling\n- Limited user feedback for errors\n- Unclear error recovery strategies\n\nRecommended Changes:\nImplement Custom Error Classes. Example:\n```javascript\n/**\n * Custom error class for API errors.\n */\nclass ApiError extends Error {\n  constructor(message, statusCode, endpoint) {\n    super(message);\n    this.name = 'ApiError';\n    this.statusCode = statusCode;\n    this.endpoint = endpoint;\n  }\n}\n\n/**\n * Custom error class for validation errors.\n */\nclass ValidationError extends Error {\n  constructor(message, field, value) {\n    super(message);\n    this.name = 'ValidationError';\n    this.field = field;\n    this.value = value;\n  }\n}\n```",
      "testStrategy": "",
      "status": "pending",
      "dependencies": [
        30
      ],
      "priority": "medium",
      "subtasks": [
        {
          "id": 1,
          "title": "Design and implement base error class",
          "description": "Create a foundational error class that extends the native Error class to serve as the parent for all custom error types",
          "dependencies": [],
          "details": "Implement a BaseError class that extends Error with properties for statusCode, isOperational flag, and any other common error attributes. Include proper constructor to handle error messages, error codes, and stack traces. Document the class with JSDoc comments explaining its purpose and usage.",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "Implement specific error subclasses",
          "description": "Create specific error subclasses that extend the base error class for different error scenarios",
          "dependencies": [
            1
          ],
          "details": "Implement error subclasses such as ValidationError, AuthenticationError, AuthorizationError, NotFoundError, DatabaseError, etc. Each subclass should have appropriate default status codes and properties relevant to its error type. Include constructors that properly call the parent class constructor and set type-specific properties.",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "Integrate custom errors with error handler",
          "description": "Connect the custom error classes with the application's error handling middleware",
          "dependencies": [
            1,
            2
          ],
          "details": "Update the error handling middleware to properly identify and process the custom error types. Implement logic to distinguish between operational errors (expected errors) and programming errors (unexpected errors). Ensure proper error responses are sent based on error type, including appropriate status codes and error messages. Add test cases to verify error handling works correctly.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 32,
      "title": "Refactor: 6.3 Implement Try-Catch Patterns",
      "description": "Implement consistent try-catch patterns throughout the codebase to ensure errors are caught and handled by the centralized error handler. This will prevent unhandled exceptions and improve application stability.",
      "details": "Current Issues:\n- Inconsistent error handling\n- Unclear error recovery strategies\n\nRecommended Changes:\nImplement Try-Catch Patterns. Example:\n```javascript\n/**\n * Example of consistent try-catch pattern.\n */\nasync function safeApiCall(endpoint, params, context) {\n  try {\n    const apiClient = ApiClient.getInstance();\n    return await apiClient.get(endpoint, params);\n  } catch (error) {\n    return ErrorHandler.handle(error, {\n      location: 'apiCall',\n      endpoint,\n      params,\n      ...context\n    });\n  }\n}\n```",
      "testStrategy": "",
      "status": "pending",
      "dependencies": [
        30,
        31
      ],
      "priority": "medium",
      "subtasks": [
        {
          "id": 1,
          "title": "Design standardized try-catch pattern",
          "description": "Create a consistent try-catch pattern template that can be used throughout the application",
          "dependencies": [],
          "details": "Define the structure of try-catch blocks including error classification, logging format, and recovery strategies. Create documentation with examples of the pattern usage in different scenarios. Consider different error types and appropriate handling strategies for each.",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "Develop helper functions for safe operations",
          "description": "Create utility functions that wrap common operations in try-catch blocks",
          "dependencies": [
            1
          ],
          "details": "Implement helper functions for common operations like API calls, file operations, and data parsing. Each function should use the standardized try-catch pattern, handle specific error cases, and provide meaningful error messages. Include retry logic where appropriate.",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "Implement context gathering for error handling",
          "description": "Create mechanisms to collect relevant context information when errors occur",
          "dependencies": [
            1
          ],
          "details": "Develop functions to gather contextual information such as user state, application state, and relevant data at the time of error. Implement a system to attach this context to error objects. Create a structured format for error reporting that includes this context.",
          "status": "pending"
        },
        {
          "id": 4,
          "title": "Apply try-catch patterns in key application areas",
          "description": "Identify and implement the standardized try-catch pattern in critical parts of the application",
          "dependencies": [
            1,
            2,
            3
          ],
          "details": "Identify critical areas of the application that require robust error handling. Implement the standardized try-catch pattern in these areas, using the helper functions and context gathering mechanisms. Focus on user-facing features, data processing functions, and integration points with external systems.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 33,
      "title": "Refactor: 7.1 Implement Unit Testing",
      "description": "Set up a basic unit testing framework for Google Apps Script to enable systematic testing of individual code units (functions, methods). This will improve code quality and help catch bugs early.",
      "details": "Current Issues:\n- Lack of systematic testing\n- Difficulty in validating code changes\n\nRecommended Changes:\nImplement Unit Testing. Set up a basic unit testing framework for Apps Script:\n```javascript\n/**\n * Simple unit testing framework.\n */\nclass TestRunner {\n  constructor() {\n    this.tests = [];\n    this.results = {\n      passed: 0,\n      failed: 0,\n      total: 0\n    };\n  }\n  \n  addTest(name, testFunc) {\n    this.tests.push({ name, testFunc });\n  }\n  \n  async runTests() {\n    for (const test of this.tests) {\n      try {\n        await test.testFunc();\n        this.results.passed++;\n        Logger.log(`✅ Test passed: ${test.name}`);\n      } catch (error) {\n        this.results.failed++;\n        Logger.log(`❌ Test failed: ${test.name}`);\n        Logger.log(`   Error: ${error.message}`);\n      }\n      this.results.total++;\n    }\n    \n    this.logResults();\n  }\n  \n  logResults() {\n    Logger.log(`\n      Test Results:\n      - Total: ${this.results.total}\n      - Passed: ${this.results.passed}\n      - Failed: ${this.results.failed}\n    `);\n  }\n}\n```",
      "testStrategy": "",
      "status": "pending",
      "dependencies": [],
      "priority": "medium",
      "subtasks": [
        {
          "id": 1,
          "title": "Design Test Runner Framework",
          "description": "Create the core test runner framework that will execute test cases and report results",
          "dependencies": [],
          "details": "Design and implement a lightweight test runner that works within Google Apps Script constraints. Include functionality for test discovery, execution flow, and result reporting. Consider the unique execution environment of Apps Script and design accordingly to handle asynchronous operations and script timeouts.",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "Implement Assertion Utilities",
          "description": "Develop a comprehensive set of assertion functions for test validation",
          "dependencies": [
            1
          ],
          "details": "Create assertion utilities that support common test scenarios: equality checks, type validation, array/object comparisons, and exception handling. Ensure clear error messages that help identify test failures quickly. Design the API to be intuitive for developers writing tests.",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "Establish Test Organization Structure",
          "description": "Define conventions for organizing tests and create folder/file structure",
          "dependencies": [
            1
          ],
          "details": "Create a consistent organization system for test files, including naming conventions, folder structure, and test grouping strategies. Document these conventions for the team. Consider how to separate unit tests from integration tests and how to organize tests to mirror the application structure.",
          "status": "pending"
        },
        {
          "id": 4,
          "title": "Implement Initial Test Suite for Core Functionality",
          "description": "Write the first set of unit tests covering critical core functionality",
          "dependencies": [
            1,
            2,
            3
          ],
          "details": "Develop an initial set of tests for the most critical parts of the application. Focus on core utility functions, data processing logic, and any complex algorithms. Aim for high coverage of essential functionality to establish a baseline for future development.",
          "status": "pending"
        },
        {
          "id": 5,
          "title": "Set Up Test Execution Automation",
          "description": "Create automation for running tests during development and in CI/CD pipelines",
          "dependencies": [
            1,
            4
          ],
          "details": "Implement automation scripts to run tests easily during development and as part of deployment processes. Include options for running specific test suites or individual tests. Create reporting mechanisms to track test coverage and results over time. Consider integration with existing CI/CD tools if applicable.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 34,
      "title": "Refactor: 7.2 Create Mock Objects for Testing",
      "description": "Develop mock objects (e.g., MockApiClient) to simulate external dependencies during testing. This will allow for isolated unit testing and faster test execution.",
      "details": "Current Issues:\n- Lack of systematic testing\n- Difficulty in validating code changes\n\nRecommended Changes:\nCreate Mock Objects for Testing. Example:\n```javascript\n/**\n * Mock API client for testing.\n */\nclass MockApiClient {\n  constructor(mockResponses) {\n    this.mockResponses = mockResponses;\n  }\n  \n  async get(endpoint, params = {}) {\n    if (this.mockResponses[endpoint]) {\n      return this.mockResponses[endpoint];\n    }\n    throw new Error(`No mock response for endpoint: ${endpoint}`);\n  }\n}\n```",
      "testStrategy": "",
      "status": "pending",
      "dependencies": [
        33
      ],
      "priority": "medium",
      "subtasks": [
        {
          "id": 1,
          "title": "Define mock object design principles",
          "description": "Establish the core principles and patterns for creating mock objects in the system",
          "dependencies": [],
          "details": "Create documentation outlining the mock object design principles including: isolation strategies, state vs. behavior verification approaches, deterministic behavior guidelines, error simulation capabilities, and consistency patterns across different mock implementations. Include examples of proper mock object usage and anti-patterns to avoid.",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "Implement core service mocks",
          "description": "Create mock implementations for API client and sheet services",
          "dependencies": [
            1
          ],
          "details": "Develop mock implementations for the API client and sheet services following the established design principles. Include methods to simulate successful responses, error conditions, and network failures. Implement configuration options to control response timing, payload contents, and error scenarios. Ensure mocks maintain proper interface compatibility with real implementations.",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "Create mock data generation utilities",
          "description": "Develop utilities to generate realistic test data for mock objects",
          "dependencies": [
            1
          ],
          "details": "Build a set of utilities to generate realistic test data for use with mock objects. Include functions for creating random but valid data structures, deterministic sequences, edge case values, and domain-specific test data. Implement factories for common data types and composable generators for complex object structures. Document usage patterns and integration with mock objects.",
          "status": "pending"
        },
        {
          "id": 4,
          "title": "Integrate mocks with test framework",
          "description": "Connect mock implementations with the existing test framework",
          "dependencies": [
            2,
            3
          ],
          "details": "Integrate the mock objects and data generation utilities with the test framework. Create helper functions or fixtures to easily inject mocks into test cases. Implement automatic mock reset/cleanup between tests. Add support for recording mock interactions for verification. Document the integration approach and provide examples of complete test cases using the mock system.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 35,
      "title": "Refactor: 7.3 Set Up Integration Tests",
      "description": "Establish integration tests to verify the interaction between different components and external services (like the API). This will ensure the system works correctly as a whole.",
      "details": "Current Issues:\n- Lack of systematic testing\n- Difficulty in validating code changes\n\nRecommended Changes:\nSet Up Integration Tests. Example:\n```javascript\n/**\n * Integration test for fetching pies.\n */\nfunction testFetchPies() {\n  const runner = new TestRunner();\n  \n  runner.addTest('Should fetch and process pies', async () => {\n    // Set up mock API client\n    const mockApiClient = new MockApiClient({\n      'equity/pies': { items: [{ id: 1, name: 'Test Pie', value: 100 }] }\n    });\n    \n    // Override API client instance\n    ApiClient.instance = mockApiClient;\n    \n    // Execute the function to test\n    const result = await fetchPies();\n    \n    // Assert the results\n    if (!result || result.length !== 1 || result[0].name !== 'Test Pie') {\n      throw new Error('Unexpected result from fetchPies');\n    }\n  });\n  \n  runner.runTests();\n}\n```",
      "testStrategy": "",
      "status": "pending",
      "dependencies": [
        33,
        34
      ],
      "priority": "medium",
      "subtasks": [
        {
          "id": 1,
          "title": "Design Integration Test Framework",
          "description": "Create a comprehensive design for the integration test framework including test architecture, patterns, and tools selection.",
          "dependencies": [],
          "details": "Define the overall integration test architecture, select appropriate testing tools and libraries, establish patterns for test organization, determine how to handle test data, and create guidelines for writing integration tests. Document the framework design decisions and rationale.",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "Set Up Test Environment",
          "description": "Configure and establish the test environment needed for running integration tests.",
          "dependencies": [
            1
          ],
          "details": "Set up test databases, configure test servers, create Docker containers if needed, establish CI/CD pipeline integration, implement environment variable management, and ensure proper isolation between test environments. Document the environment setup process.",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "Implement Core Workflow Tests",
          "description": "Develop integration tests for core business workflows and processes.",
          "dependencies": [
            1,
            2
          ],
          "details": "Identify critical business workflows, create test cases that verify end-to-end functionality, implement tests that cover the main user journeys, establish proper test data setup and teardown, and ensure tests validate the integration points between core components.",
          "status": "pending"
        },
        {
          "id": 4,
          "title": "Implement API Integration Tests",
          "description": "Create tests that verify the correct integration between API endpoints and backend services.",
          "dependencies": [
            1,
            2
          ],
          "details": "Develop tests for API authentication, implement tests for all critical API endpoints, verify proper error handling and status codes, test API rate limiting and performance characteristics, and ensure data consistency across API calls.",
          "status": "pending"
        },
        {
          "id": 5,
          "title": "Implement UI Integration Tests",
          "description": "Develop tests that verify the integration between UI components and backend services.",
          "dependencies": [
            1,
            2
          ],
          "details": "Set up UI testing tools (like Selenium, Cypress, or Playwright), implement tests for critical user interfaces, verify proper data display and form submissions, test UI workflows that span multiple pages or components, and ensure proper error handling and user feedback in the UI.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 36,
      "title": "Refactor: 8.1 Standardize Code Documentation",
      "description": "Adopt and apply a consistent JSDoc style for documenting all functions, classes, and modules. This will improve code readability and maintainability.",
      "details": "Current Issues:\n- Inconsistent documentation style\n- Missing documentation for key functionality\n\nRecommended Changes:\nStandardize Code Documentation. Adopt a consistent JSDoc style for all functions and classes:\n```javascript\n/**\n * Fetches investment pies from the Trading212 API.\n * \n * @async\n * @function fetchPies\n * @param {Object} [options] - Optional configuration for the fetch operation.\n * @param {number} [options.limit=20] - Maximum number of pies to fetch.\n * @param {string} [options.cursor] - Cursor for pagination.\n * @returns {Promise<Array<PieModel>>} Array of pie models.\n * @throws {ApiError} When the API request fails.\n * \n * @example\n * // Fetch pies with default options\n * const pies = await fetchPies();\n * \n * // Fetch pies with custom options\n * const pies = await fetchPies({ limit: 50 });\n */\nasync function fetchPies(options = {}) {\n  // Implementation...\n}\n```",
      "testStrategy": "",
      "status": "pending",
      "dependencies": [],
      "priority": "low",
      "subtasks": [
        {
          "id": 1,
          "title": "Create Documentation Style Guide",
          "description": "Develop a comprehensive JSDoc style guide for the project that defines standards for all code documentation",
          "dependencies": [],
          "details": "Create a documentation style guide that includes: formatting rules, required tags (@param, @returns, etc.), examples of properly documented code, naming conventions, and documentation depth requirements for different code elements. This guide should be stored in a central location accessible to all developers.",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "Implement Core Module and Class Documentation",
          "description": "Apply the documentation style guide to all core modules and classes in the codebase",
          "dependencies": [
            1
          ],
          "details": "Add or update JSDoc comments for all core modules and classes following the established style guide. Include detailed descriptions of module/class purpose, usage examples, and any important implementation details. Focus on high-level documentation that explains the role of each component in the system.",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "Implement Function and Method Documentation",
          "description": "Document all functions and methods throughout the codebase according to the style guide",
          "dependencies": [
            1,
            2
          ],
          "details": "Add or update JSDoc comments for all functions and methods, ensuring proper documentation of parameters, return values, exceptions, and edge cases. Include examples where appropriate, especially for complex functions. Ensure consistency with the documentation style guide and maintain alignment with the higher-level documentation created for modules and classes.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 37,
      "title": "Refactor: 8.2 Create Technical Documentation",
      "description": "Create a comprehensive technical documentation file covering the architecture, module responsibilities, API interactions, data processing flow, error handling, and configuration options. This will aid developers in understanding and contributing to the project.",
      "details": "Current Issues:\n- Inconsistent documentation style\n- Missing documentation for key functionality\n\nRecommended Changes:\nCreate Technical Documentation. Create a comprehensive technical documentation file explaining:\n- Architecture overview\n- Module responsibilities\n- API interactions\n- Data processing flow\n- Error handling strategy\n- Configuration options",
      "testStrategy": "",
      "status": "pending",
      "dependencies": [
        16,
        17,
        21,
        24,
        30
      ],
      "priority": "low",
      "subtasks": [
        {
          "id": 1,
          "title": "Create Architecture Documentation",
          "description": "Document the high-level system architecture including system components, interactions, and design patterns",
          "dependencies": [],
          "details": "Include system diagrams, architectural decisions, technology stack overview, and system constraints. Document the overall structure, layers, and how different parts of the system interact with each other.",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "Develop Module and Component Documentation",
          "description": "Create detailed documentation for each module and component in the system",
          "dependencies": [
            1
          ],
          "details": "Document the purpose, functionality, and implementation details of each module. Include class/component diagrams, code organization, and internal workflows. Cover both frontend and backend components with appropriate code examples.",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "Document APIs and Data Flows",
          "description": "Create comprehensive documentation for all APIs and data flows within the system",
          "dependencies": [
            1,
            2
          ],
          "details": "Document all API endpoints, request/response formats, authentication mechanisms, and error handling. Include data flow diagrams showing how information moves through the system. Document database schemas and any external service integrations.",
          "status": "pending"
        },
        {
          "id": 4,
          "title": "Prepare Configuration and Deployment Documentation",
          "description": "Document all configuration options and deployment procedures",
          "dependencies": [
            1
          ],
          "details": "Create documentation covering environment setup, configuration parameters, deployment pipelines, and infrastructure requirements. Include troubleshooting guides, monitoring setup, and maintenance procedures. Document scaling considerations and disaster recovery processes.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 38,
      "title": "Refactor: 8.3 Create User Documentation",
      "description": "Develop user-friendly documentation covering installation, setup, data fetching, sheet customization, and troubleshooting. This will help users effectively utilize the add-on.",
      "details": "Current Issues:\n- Limited user guides\n\nRecommended Changes:\nCreate User Documentation. Create user-friendly guides for:\n- Installation and setup\n- Connecting to Trading212 API\n- Fetching and updating data\n- Customizing sheets and reports\n- Troubleshooting common issues",
      "testStrategy": "",
      "status": "pending",
      "dependencies": [],
      "priority": "low",
      "subtasks": [
        {
          "id": 1,
          "title": "Create Installation and Setup Guide",
          "description": "Develop a comprehensive guide for installing and setting up the software",
          "dependencies": [],
          "details": "Include system requirements, step-by-step installation instructions for different operating systems, configuration options, and initial setup procedures. Add screenshots where helpful and verify all steps work as documented.",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "Develop Feature Usage Documentation",
          "description": "Document all features and their usage with examples",
          "dependencies": [
            1
          ],
          "details": "Create detailed documentation for each feature, including purpose, how to access it, configuration options, and practical usage examples. Include screenshots, use cases, and tips for optimal usage. Organize features logically by category.",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "Create Troubleshooting Guide",
          "description": "Develop a guide addressing common issues and their solutions",
          "dependencies": [
            2
          ],
          "details": "Identify common problems users might encounter, document error messages, their causes, and step-by-step solutions. Include diagnostic procedures, logs to check, and when to contact support. Test solutions to ensure accuracy.",
          "status": "pending"
        },
        {
          "id": 4,
          "title": "Compile FAQ and Best Practices",
          "description": "Create a collection of frequently asked questions and recommended best practices",
          "dependencies": [
            2,
            3
          ],
          "details": "Gather common questions from users or anticipated questions, provide clear answers. Document recommended workflows, optimization tips, and usage patterns that maximize value. Include real-world scenarios and performance considerations.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 39,
      "title": "Feature: 9.1 Enhanced Data Visualization",
      "description": "Implement enhanced data visualization features, including automatic chart generation for portfolio performance, dynamic dashboards, and customizable visualization options. This will provide users with better insights into their portfolio.",
      "details": "New Features:\nEnhanced Data Visualization\n- Implement automatic chart generation for portfolio performance\n- Add dynamic dashboards summarizing portfolio metrics\n- Create customizable visualization options\n\nExample implementation for automatic chart generation:\n```javascript\n/**\n * Creates a portfolio performance chart in the given sheet.\n * \n * @param {string} sheetName - The name of the sheet to create the chart in.\n * @param {Array<Object>} performanceData - Array of performance data points.\n */\nfunction createPortfolioPerformanceChart(sheetName, performanceData) {\n  const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(sheetName);\n  \n  // Prepare data for chart\n  const headers = ['Date', 'Value'];\n  const rows = performanceData.map(item => [item.date, item.value]);\n  \n  // Write data to sheet\n  sheet.getRange(1, 1, 1, headers.length).setValues([headers]);\n  sheet.getRange(2, 1, rows.length, rows[0].length).setValues(rows);\n  \n  // Create chart\n  const chart = sheet.newChart()\n    .setChartType(Charts.ChartType.LINE)\n    .addRange(sheet.getRange(1, 1, rows.length + 1, 2))\n    .setPosition(5, 5, 0, 0)\n    .setOption('title', 'Portfolio Performance')\n    .setOption('legend', {position: 'none'})\n    .setOption('vAxis', {title: 'Value'})\n    .setOption('hAxis', {title: 'Date'})\n    .build();\n  \n  sheet.insertChart(chart);\n}\n```",
      "testStrategy": "",
      "status": "pending",
      "dependencies": [
        24,
        25
      ],
      "priority": "medium",
      "subtasks": [
        {
          "id": 1,
          "title": "Chart Generation Framework Design",
          "description": "Design and implement a reusable chart generation framework that will serve as the foundation for all visualizations",
          "dependencies": [],
          "details": "Create a modular framework that handles data processing, chart configuration, and rendering. Define standard interfaces for different chart types. Implement utility functions for data transformation and formatting. Ensure compatibility with Google Sheets' chart capabilities and APIs. Document the framework architecture and usage guidelines.",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "Portfolio Performance Visualization",
          "description": "Implement visualizations for tracking portfolio performance over time",
          "dependencies": [
            1
          ],
          "details": "Create line charts showing portfolio value over time. Implement comparison charts against benchmarks. Add performance metrics visualization (e.g., CAGR, Sharpe ratio). Include interactive elements for time period selection. Ensure proper handling of currency conversions and adjustments for deposits/withdrawals.",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "Asset Allocation Visualization",
          "description": "Develop visualizations showing the breakdown of assets in the portfolio",
          "dependencies": [
            1
          ],
          "details": "Create pie/donut charts for asset class allocation. Implement treemap visualizations for hierarchical asset breakdowns. Add bar charts for sector/industry allocation. Include geographic distribution maps if applicable. Ensure visualizations update dynamically as portfolio changes.",
          "status": "pending"
        },
        {
          "id": 4,
          "title": "Transaction History Visualization",
          "description": "Implement visualizations for transaction history and patterns",
          "dependencies": [
            1
          ],
          "details": "Create timeline visualizations of buy/sell transactions. Implement heatmaps showing transaction frequency. Add bar charts for transaction volume analysis. Include filtering capabilities by asset type, date range, and transaction type. Ensure proper handling of transaction categories and tagging.",
          "status": "pending"
        },
        {
          "id": 5,
          "title": "Dividend Visualization",
          "description": "Develop visualizations for dividend income and distribution",
          "dependencies": [
            1
          ],
          "details": "Create bar charts showing dividend income over time. Implement visualizations for dividend yield by asset. Add projections for future dividend income. Include seasonal patterns visualization for dividend payments. Ensure proper handling of dividend reinvestment in calculations.",
          "status": "pending"
        },
        {
          "id": 6,
          "title": "Dashboard Integration",
          "description": "Integrate all visualizations into a cohesive dashboard interface",
          "dependencies": [
            2,
            3,
            4,
            5
          ],
          "details": "Design a unified dashboard layout. Implement navigation between different visualization sections. Add customization options for user preferences. Ensure responsive design for different screen sizes. Create print/export functionality for reports. Test dashboard performance with large datasets.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 40,
      "title": "Feature: 9.2 Scheduled Refreshes",
      "description": "Add functionality to automatically refresh portfolio data on a configurable schedule (e.g., daily, hourly) using time-driven triggers. Implement optional email notifications for significant portfolio changes.",
      "details": "New Features:\nScheduled Refreshes\n- Add functionality to automatically refresh data on a schedule\n- Implement configurable refresh intervals (daily, hourly, etc.)\n- Add email notifications for significant portfolio changes\n\nExample implementation for scheduled refreshes:\n```javascript\n/**\n * Sets up a time-driven trigger to refresh data on a schedule.\n * \n * @param {string} frequency - The frequency of the refresh ('hourly', 'daily', 'weekly').\n */\nfunction setupScheduledRefresh(frequency) {\n  // Delete any existing triggers\n  const triggers = ScriptApp.getProjectTriggers();\n  for (const trigger of triggers) {\n    if (trigger.getHandlerFunction() === 'refreshPortfolioData') {\n      ScriptApp.deleteTrigger(trigger);\n    }\n  }\n  \n  // Create new trigger based on frequency\n  switch (frequency) {\n    case 'hourly':\n      ScriptApp.newTrigger('refreshPortfolioData')\n        .timeBased()\n        .everyHours(1)\n        .create();\n      break;\n    case 'daily':\n      ScriptApp.newTrigger('refreshPortfolioData')\n        .timeBased()\n        .everyDays(1)\n        .atHour(6) // 6 AM\n        .create();\n      break;\n    case 'weekly':\n      ScriptApp.newTrigger('refreshPortfolioData')\n        .timeBased()\n        .onWeekDay(ScriptApp.WeekDay.MONDAY)\n        .atHour(6) // 6 AM\n        .create();\n      break;\n  }\n  \n  // Save the configuration\n  PropertiesService.getUserProperties().setProperty('REFRESH_FREQUENCY', frequency);\n}\n```",
      "testStrategy": "",
      "status": "pending",
      "dependencies": [
        25
      ],
      "priority": "medium",
      "subtasks": [
        {
          "id": 1,
          "title": "Design Trigger Management System",
          "description": "Create a system to manage time-based triggers for scheduled refreshes",
          "dependencies": [],
          "details": "Design and implement a trigger management system that can schedule and execute data refreshes at specified intervals. Include support for one-time and recurring schedules (hourly, daily, weekly, monthly). Define the data model for storing trigger configurations and implement the core scheduling logic that will activate refreshes at the appropriate times.",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "Develop Refresh Configuration UI",
          "description": "Create user interface components for configuring scheduled refreshes",
          "dependencies": [
            1
          ],
          "details": "Design and implement UI components that allow users to create, edit, and delete scheduled refreshes. Include options for setting refresh frequency, time windows, data sources to refresh, and notification preferences. Ensure the UI is intuitive and provides clear feedback on the configured schedule.",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "Implement Automated Refresh Execution",
          "description": "Build the system that executes data refreshes based on configured schedules",
          "dependencies": [
            1
          ],
          "details": "Implement the execution engine that runs when a scheduled refresh is triggered. This should handle the actual data refresh process, including connecting to data sources, fetching updated data, and updating the application's data store. Include error handling, retry logic, and performance optimizations to ensure reliable execution.",
          "status": "pending"
        },
        {
          "id": 4,
          "title": "Create Notification System for Refresh Status",
          "description": "Develop a system to notify users about the status of scheduled refreshes",
          "dependencies": [
            3
          ],
          "details": "Implement a notification system that alerts users about the status of scheduled refreshes (started, completed, failed). Support multiple notification channels (in-app, email, push notifications) and allow users to configure their notification preferences. Include detailed information about refresh results, including any errors encountered.",
          "status": "pending"
        },
        {
          "id": 5,
          "title": "Implement Refresh History Logging",
          "description": "Create a system to log and display the history of scheduled refreshes",
          "dependencies": [
            3,
            4
          ],
          "details": "Design and implement a logging system that records details about each refresh execution, including start time, end time, duration, status, and any errors. Create a UI to display refresh history with filtering and sorting options. Include metrics and statistics about refresh performance over time to help users optimize their refresh schedules.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 41,
      "title": "Feature: 9.3 Portfolio Analysis",
      "description": "Implement portfolio analysis tools, including performance metrics calculation, sector allocation analysis, dividend tracking and forecasting, and risk assessment tools. This will provide users with deeper insights into their portfolio's characteristics.",
      "details": "New Features:\nPortfolio Analysis\n- Implement portfolio performance metrics calculation\n- Add sector allocation analysis\n- Create dividend tracking and forecasting\n- Implement risk assessment tools\n\nExample implementation for sector allocation analysis:\n```javascript\n/**\n * Analyzes sector allocation in the portfolio.\n * \n * @returns {Object} Sector allocation data.\n */\nfunction analyzeSectorAllocation() {\n  const holdings = getPortfolioHoldings();\n  const sectors = {};\n  \n  // Calculate sector totals\n  for (const holding of holdings) {\n    if (!sectors[holding.sector]) {\n      sectors[holding.sector] = 0;\n    }\n    sectors[holding.sector] += holding.value;\n  }\n  \n  // Calculate percentages\n  const totalValue = holdings.reduce((sum, holding) => sum + holding.value, 0);\n  const sectorAllocation = Object.entries(sectors).map(([sector, value]) => ({\n    sector,\n    value,\n    percentage: (value / totalValue) * 100\n  }));\n  \n  // Sort by percentage (descending)\n  sectorAllocation.sort((a, b) => b.percentage - a.percentage);\n  \n  return sectorAllocation;\n}\n```",
      "testStrategy": "",
      "status": "pending",
      "dependencies": [
        24,
        25
      ],
      "priority": "medium",
      "subtasks": [
        {
          "id": 1,
          "title": "Implement Performance Metrics Calculation",
          "description": "Develop algorithms to calculate key portfolio performance metrics including returns (absolute, relative, annualized), alpha, beta, Sharpe ratio, and Sortino ratio.",
          "dependencies": [],
          "details": "Create modular functions for each metric calculation. Ensure time-weighted return calculations account for cash flows. Implement rolling period calculations (1M, 3M, YTD, 1Y, 3Y, 5Y, Max). Include proper error handling for missing data points.",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "Develop Sector Allocation Analysis",
          "description": "Create tools to analyze and visualize portfolio sector allocation, sector drift over time, and sector performance contribution.",
          "dependencies": [
            1
          ],
          "details": "Implement sector classification mapping system. Create visualization components for current allocation vs benchmark. Develop historical sector drift tracking. Calculate sector attribution analysis to identify performance drivers. Include over/underweight indicators.",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "Build Dividend Tracking and Forecasting System",
          "description": "Implement functionality to track historical dividends and forecast future dividend income based on current holdings and historical patterns.",
          "dependencies": [
            1
          ],
          "details": "Create dividend calendar visualization. Implement dividend reinvestment simulation. Develop yield calculation and tracking over time. Build forecasting models using historical payout patterns and announced dividends. Include tax impact estimation.",
          "status": "pending"
        },
        {
          "id": 4,
          "title": "Implement Risk Assessment Tools",
          "description": "Develop comprehensive risk analysis tools including volatility metrics, drawdown analysis, VaR calculations, and stress testing capabilities.",
          "dependencies": [
            1
          ],
          "details": "Implement standard deviation, downside deviation, and maximum drawdown calculations. Create Monte Carlo simulation for portfolio projections. Develop Value at Risk (VaR) with multiple confidence intervals. Build stress testing framework for historical and hypothetical scenarios.",
          "status": "pending"
        },
        {
          "id": 5,
          "title": "Create Benchmark Comparison System",
          "description": "Implement tools to compare portfolio performance against multiple benchmarks with customizable time periods and visualization options.",
          "dependencies": [
            1,
            4
          ],
          "details": "Develop benchmark data integration from multiple sources. Create relative performance charts with customizable time periods. Implement tracking error calculations. Build benchmark-relative risk metrics. Include custom benchmark creation functionality.",
          "status": "pending"
        },
        {
          "id": 6,
          "title": "Develop Historical Performance Analysis",
          "description": "Build tools for detailed historical performance analysis including rolling returns, drawdown periods, and performance attribution.",
          "dependencies": [
            1,
            4,
            5
          ],
          "details": "Implement rolling returns visualization for multiple time periods. Create drawdown analysis with recovery time tracking. Develop performance attribution by security, sector, and asset class. Build calendar year and monthly return tables. Include correlation analysis with market factors.",
          "status": "pending"
        },
        {
          "id": 7,
          "title": "Integrate Analysis Dashboard",
          "description": "Create a comprehensive dashboard integrating all analysis components with interactive visualizations and customizable reporting options.",
          "dependencies": [
            1,
            2,
            3,
            4,
            5,
            6
          ],
          "details": "Design intuitive UI layout with key metrics prominently displayed. Implement interactive charts with drill-down capabilities. Create customizable dashboard views for different user needs. Develop PDF/Excel report generation. Build alert system for key metric thresholds. Ensure responsive design for multiple devices.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 42,
      "title": "Feature: 9.4 Mobile Compatibility",
      "description": "Optimize the user interface for mobile use by implementing responsive design principles and creating mobile-friendly views for key information. This will improve the user experience on mobile devices.",
      "details": "New Features:\nMobile Compatibility\n- Optimize UI for mobile use\n- Create mobile-friendly views for key information\n- Implement responsive design principles\n\nExample approach for mobile compatibility:\n```html\n<!-- Example of responsive CSS for mobile compatibility -->\n<style>\n  /* Base styles */\n  .setup-container {\n    padding: 20px;\n  }\n  \n  /* Responsive styles */\n  @media screen and (max-width: 600px) {\n    .setup-container {\n      padding: 10px;\n    }\n    \n    .environment-cards {\n      flex-direction: column;\n    }\n    \n    .environment-card {\n      width: 100%;\n      margin-bottom: 15px;\n    }\n    \n    .button-container {\n      flex-direction: column;\n      gap: 10px;\n    }\n    \n    .button-container button {\n      width: 100%;\n    }\n  }\n</style>\n```",
      "testStrategy": "",
      "status": "pending",
      "dependencies": [
        27,
        29
      ],
      "priority": "medium",
      "subtasks": [
        {
          "id": 1,
          "title": "Implement Responsive Design Framework",
          "description": "Select and implement a responsive design framework that will serve as the foundation for mobile compatibility.",
          "dependencies": [],
          "details": "Research and select an appropriate responsive framework (e.g., Bootstrap, Tailwind CSS). Implement the core responsive grid system. Set up viewport configurations and breakpoints for different device sizes. Create a responsive container structure that will adapt to various screen sizes.",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "Adapt UI Components for Mobile",
          "description": "Modify existing UI components to be mobile-friendly with appropriate sizing and interaction patterns.",
          "dependencies": [
            1
          ],
          "details": "Resize buttons, form elements, and interactive components for touch targets. Implement collapsible menus and navigation for smaller screens. Adjust typography and spacing for readability on mobile devices. Replace hover interactions with mobile-appropriate alternatives.",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "Optimize Touch Interactions",
          "description": "Enhance the application with touch-specific interactions and gestures for mobile users.",
          "dependencies": [
            2
          ],
          "details": "Implement swipe gestures for common actions. Add touch feedback (visual/haptic) for interactive elements. Ensure sufficient spacing between clickable elements to prevent touch errors. Replace drag-and-drop interactions with mobile-friendly alternatives where necessary.",
          "status": "pending"
        },
        {
          "id": 4,
          "title": "Conduct Mobile Layout Testing",
          "description": "Test the application on various mobile devices and screen sizes to ensure consistent layout and functionality.",
          "dependencies": [
            2,
            3
          ],
          "details": "Create a test matrix covering different device types, screen sizes, and orientations. Test navigation flows and user journeys on mobile devices. Verify that all content is accessible on smaller screens. Document and fix any layout issues or breakpoints problems.",
          "status": "pending"
        },
        {
          "id": 5,
          "title": "Optimize Performance for Mobile",
          "description": "Improve application performance specifically for mobile devices with limited resources and potentially slower connections.",
          "dependencies": [
            4
          ],
          "details": "Optimize image loading and sizing for mobile screens. Implement lazy loading for content below the fold. Reduce JavaScript payload and execution time for mobile processors. Test and optimize load times on various connection speeds (3G, 4G, etc.). Consider implementing a Progressive Web App approach if appropriate.",
          "status": "pending"
        }
      ]
    },
    {
      "id": 43,
      "title": "Feature: 9.5 Data Export Options",
      "description": "Add functionality to export portfolio data in various formats (CSV, PDF) and implement options for email report delivery and custom report templates. This will provide users with more flexibility in accessing and sharing their data.",
      "details": "New Features:\nData Export Options\n- Add functionality to export portfolio data in various formats (CSV, PDF)\n- Create email report delivery options\n- Implement custom report templates\n\nExample implementation for CSV export:\n```javascript\n/**\n * Exports portfolio data to CSV.\n * \n * @param {string} sheetName - The name of the sheet to export.\n * @returns {string} CSV data as a string.\n */\nfunction exportSheetToCsv(sheetName) {\n  const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(sheetName);\n  const data = sheet.getDataRange().getValues();\n  \n  // Convert to CSV\n  const csv = data.map(row => row.join(',')).join('\\n');\n  \n  return csv;\n}\n\n/**\n * Creates and emails a portfolio report.\n * \n * @param {string} email - The email address to send the report to.\n * @param {string} reportType - The type of report to generate ('summary', 'detailed').\n */\nfunction emailPortfolioReport(email, reportType) {\n  // Generate report data\n  const reportData = generatePortfolioReport(reportType);\n  \n  // Export to CSV\n  const csv = exportSheetToCsv(reportData.sheetName);\n  \n  // Create blob\n  const blob = Utilities.newBlob(csv, 'text/csv', `Portfolio_Report_${new Date().toISOString().slice(0, 10)}.csv`);\n  \n  // Send email\n  MailApp.sendEmail({\n    to: email,\n    subject: 'Your Trading212 Portfolio Report',\n    body: 'Please find your portfolio report attached.',\n    attachments: [blob]\n  });\n}\n```",
      "testStrategy": "",
      "status": "pending",
      "dependencies": [
        25
      ],
      "priority": "medium",
      "subtasks": [
        {
          "id": 1,
          "title": "Design Export Format Handler Interface",
          "description": "Create a flexible interface/abstract class that defines the contract for all export format handlers",
          "dependencies": [],
          "details": "Design a robust interface that allows for different export format implementations. Include methods for data transformation, formatting options, and file generation. Consider extensibility for future formats beyond CSV and PDF. Document the interface with clear specifications for implementers.",
          "status": "pending"
        },
        {
          "id": 2,
          "title": "Implement CSV Export Functionality",
          "description": "Develop the CSV export handler implementing the export format interface",
          "dependencies": [
            1
          ],
          "details": "Create a CSV export implementation that handles data serialization, proper escaping of special characters, column headers, and configurable delimiters. Include options for data filtering and column selection. Implement proper error handling for malformed data.",
          "status": "pending"
        },
        {
          "id": 3,
          "title": "Implement PDF Export Functionality",
          "description": "Develop the PDF export handler implementing the export format interface",
          "dependencies": [
            1
          ],
          "details": "Create a PDF export implementation that formats data appropriately for PDF documents. Research and integrate a suitable PDF generation library. Implement features for page headers/footers, pagination, and basic styling. Handle complex data types and potential rendering issues.",
          "status": "pending"
        },
        {
          "id": 4,
          "title": "Develop Email Delivery System",
          "description": "Create a system to deliver exported files via email",
          "dependencies": [
            2,
            3
          ],
          "details": "Implement an email delivery service that can attach exported files (CSV, PDF) to emails. Include configurable email templates, recipient management, and scheduling capabilities. Ensure proper error handling and delivery status tracking. Consider rate limiting and retry logic for failed deliveries.",
          "status": "pending"
        },
        {
          "id": 5,
          "title": "Build Custom Report Template System",
          "description": "Create a template system allowing users to define custom export formats and layouts",
          "dependencies": [
            2,
            3,
            4
          ],
          "details": "Develop a flexible template system that allows users to define custom report layouts and content. Implement a template editor with preview functionality. Support variable substitution, conditional sections, and formatting options. Create a template storage and management system with version control capabilities.",
          "status": "pending"
        }
      ]
    }
  ]
}